<?xml version="1.0"?>

<document>

 <header>
  <title>Velocity User Guide</title>
  <subtitle>Velocity User Guide</subtitle>
  <authors>
   <person name="Velocity Documentation Team" email="jvanzyl@locus.apache.org"/>
  </authors>
 </header>

<body>

<s1 title="About this Guide">

 <p>
    The Velocity User Guide is intended to help page designers and content 
    providers get aquainted with Velocity and the syntax of its simple yet 
    powerful scripting language, the Velocity Template Language (VTL). 
    Many of the examples in this guide deal with using Velocity to embed 
    dynamic content in web sites, but all VTL examples are equally applicable 
    to other pages and templates.
 </p> 

</s1>

<s1 title="What is Velocity?">
 
 <p>
    Velocity is a Java-based template engine. It permits web page designers
    to reference methods defined in Java code. Web designers can work in parallel 
    with Java programmers to develop web sites according to the Model-View-Controller
    (MVC) model, meaning that web page designers can focus solely on creating
    a well-designed site, and programmers can focus solely on writing
    top-notch code. Velocity separates Java code from the web pages,
    making the web site more maintainable over the long run and providing
    a viable alternative to
    <link href="http://java.sun.com/products/jsp/">Java Server Pages</link>
    (JSPs) or <link href="http://www.php.net/">PHP</link>.
 </p>
 
 <p>
    Velocity can be used to generate web pages, SQL, PostScript and other 
    output from templates.
    It can be used either as a standalone utility for generating
    source code and reports, or as an integrated component of other systems.
    When complete, Velocity will provide template services for the
    <link href="http://java.apache.org/turbine/">Turbine</link>
    web application framework. Velocity-Turbine will provide
    a template service that will allow web applications to be developed
    according to a true MVC model.
 </p>
 
</s1>

<s1 title="What can Velocity do for me?">

 <s1 title="The Mud Store Example">

   <p>
    Suppose you are a page designer for an online store that specializes in selling mud. 
    Let's call it "The Online Mud Store". Business is thriving. Customers 
    place orders for various types and quantities of mud. They
    login to your site using their username and password, which allows them to 
    view their orders and buy more mud. Right now, Terracotta Mud is on sale, which
    is very popular. A minority of your customers regularly buy Bright Red 
    Mud, which is also on sale, though not as popular and usually relegated 
    to the margin of your web page. Information about each customer is tracked
    in your database, so it occurs to you one day, Why not use Velocity to target
    special deals on mud to the customers who are most interested in those types of 
    mud?
   </p>
 
   <p>
    Velocity makes it easy to customize web pages to your online visitors. As a web site 
    designer at The Mud Room, you want to make the web page that the customer will 
    see after logging into your site.
   </p>
 
   <p>
    You meet with software engineers at your company, and everyone
    has agreed that <pre>$customer</pre> will hold information
    pertaining to the customer currently logged in,
    that <pre>$mudsOnSpecial</pre> will be all the types mud on sale at present.
    The <pre>$flogger</pre> object contains methods that help with promotion.
    For the task at hand, let's concern ourselves only with these three 
    references. Remember, you don't need to worry about how the software 
    engineers extract the necessary information from the database, you just need
    to know that it works. This lets you get on with your job, and lets the
    software engineers get on with theirs.
   </p>
 
   <p>
    You could embed the following VTL statement in the web page:
   </p>
 
   <p>
    <source><![CDATA[
    <HTML>
    <BODY>
    Hello $customer.Name!
    <table>
    #foreach ($mud in $mudsOnSpecial)
       #if ($customer.hasPurchased($mud))
          <tr>
            <td>
              $flogger.getPromo($mud)
            </td>
          </tr>
       #end
    #end
    </table>
    ]]></source>
   </p>
 
   <p>
    The extact details of the <pre>foreach</pre> statement will be described
    in greater depth shortly; what's important is the impact this short 
    script can have on your web site. When a customer with a 
    penchant for Bright Red Mud logs in, and Bright Red Mud
    is on sale, that is what this customer will see, prominently displayed. 
    If another customer with a long history of Terracotta Mud purchases logs in,
    the notice of a Terracotta Mud sale will be front and center. 
    The flexibility of Velocity is enormous and limited only by your creativity.
   </p>
 
   <p>
    Documented in the VTL Reference are the many other Velocity elements, which 
    collectively give you the power and flexibility you need to make your web site a web
    <em>presence</em>. As you get more familiar with these elements, you will begin to 
    unleash the power of Velocity.
   </p>

 </s1>

</s1>

<s1 title="Velocity Template Language (VTL): An Introduction">

 <p>
    The Velocity Template 
    Language (VTL) is meant to provide the easiest, simplest, and cleanest way 
    to incorporate dynamic content in a web page. Even a web page developer with little 
    or no programming experience should soon be capable of using VTL to incorporate 
    dynamic content in a web site.
 </p>

 <p>
    VTL uses <em>references</em> to embed dynamic content in a web site, and a variable 
    is one type of reference. Variables are one type of reference that can refer to 
    something defined in the Java code, or it can get its value from a VTL 
    <em>statement</em> in the web page itself. Here is an example of a VTL statement 
    that could be embedded in an HTML document:
 </p>
 
 <p>
    <source><![CDATA[
    #set $a = "Velocity"
    ]]>
    </source>
 </p>

 <p>
    This VTL statement, like all VTL statements, begins with the <pre>#</pre> 
    character and contains a directive (<pre>set</pre>. When an online visitor requests 
    your web page, the Velocity Templating Engine will search through your web page to 
    find all <pre>#</pre> characters, then determine which mark the beginning of VTL 
    statements, and which of the # characters that have nothing to do with VTL.
 </p>

 <p>
    The <pre>#</pre> character is followed by a directive, <pre>set</pre>. The 
    <pre>set</pre> directive uses an equation to assign a <em>value</em> to 
    a <em>variable</em>. The variable 
    is listed on the left hand side and its value on the right hand side; 
    the two are separated by an 
    <pre>=</pre> character.
 </p>
 
 <p>
    In the example above, the variable is <pre>$a</pre> and the value is
    <pre>Velocity</pre>. References <em>always</em> begin with <pre>$</pre>
    characters; all variables are references, ergo all variables begin
    with <pre>$</pre> characters.
    Values are always enclosed in quotes; with Velocity there is no confusion about
    data types, as only strings (text-based information) may be passed to variables.
 </p>

</s1>

<s1 title="Hello Velocity World!">

 <p>
    Once a value has been assigned to a variable, you can reference the 
    variable anywhere in your HTML document. In the following example, 
    a value is assigned to <pre>$foo</pre> and later referenced.
 </p>

 <p>
    <source><![CDATA[
    <HTML>
    <BODY>
    #set $foo = "Velocity"
    Hello $foo World!
    </BODY>
    <HTML>
    ]]>
    </source>
 </p>

 <p>
    The result is a web page that prints "Hello Velocity World!".
 </p>

 <p>   
    To make statements containing VTL directives more readable, we encourage you to 
    start each VTL statement on a new line, although you are not required to 
    do so. The <pre>set</pre> directive will be revisited in greater detail 
    later on.
 </p>

</s1>

<s1 title="Comments">
 
 <p>
    Comments allows descriptive text to be included that is not placed into the
    output of the template engine. Comments are a useful way of reminding 
    yourself and explaining to others what your VTL statements are doing, or 
    any other purpose you find useful. Below is an example of a comment in VTL.
 </p> 

 <p>
 <source><![CDATA[
    ## This is a single line comment.
 ]]></source>
 </p>
 
 <p>
    A single line comment begins with <pre>##</pre> and finishes at the end of the line.
    If you're going to write a few lines of commentary, there's no need to have numerous
    single line comments. Multiline comments, which begin with <pre>#*</pre>
    and end with <pre>*#</pre>, are available to handle this scenario.
 </p>
 
 <p>
 <source><![CDATA[

    This is text that is outside the multi-line comment. Online visitors can see it.

    #*
    Thus begins a multi-line comment. Online visitors won't see this text because 
    the Velocity Templating Engine will ignore it.
    *#
    
    Here is text outside the multi-line comment; it is visible. 

 ]]></source>
 </p>

 <p>
    Here's a few examples to clarify how single line and multi-line comments 
    work:
 </p>

 <p>
 <source><![CDATA[
    This text is visible. ## This text is not.
    This text is visible.
    This text is visible. #* This text, as part of a comment block, is not.
    This text is not visible; it is also part of the comment block.
    This text still not visible. *# This text is outside the comment block, so
    it is visible.
    ## This text is not visible.
 ]]></source>
 </p>

 <p>
    There is a third type of comment, the VTL comment block, which ma y be used to
    store such information as the document author and versioning information:
 </p>
 
 <p>
 <source><![CDATA[
    #** 
    This is a VTL comment block and
    may be used to store such information 
    as the document author and versioning
    information:    
    @author 
    @version 5
    *#
 ]]></source>
 </p>
 
</s1>


<s1 title="References, revisited">

 <p>
    There are three types of references in the VTL: variables, properties
    and methods. As a designer using the VTL, you and your engineers must
    come to an agreement on the specific names of references so
    you can use them correctly in your templates.
 </p>

 <p>
    Everything coming to and from a reference is treated as a String object. 
    If there is an object that represents $foo (such as an Integer object), 
    then Velocity will call its .toString() method to resolve the 
    object into a String.
 </p>

 <p>
 <strong>Variables</strong>
 <br/>
    The shorthand notation of a variable consists of a leading "$" character
    followed by a VTL <em>Identifier</em>. A VTL Identifier must 
    start with an alphabetic character (a .. z or A .. Z); the rest of the
    characters are limited to the following types of characters: alphabetic,
    numeric (0 .. 9), hyphen ("-"), and underscore ("_"). 
    Here are some examples of valid variable references in the VTL: 
 </p>

 <p>
    <source><![CDATA[
    $foo
    $mudSlinger
    $mud-slinger
    $mud_slinger
    $mudSlinger1
    ]]></source>
 </p>

 <p>
    When VTL references a variable, such as <pre>$foo</pre>, the variable can 
    get its value from either a <pre>set</pre> directive in the template, or from the
    Java code. For example, if the Java variable <pre>$foo</pre>
    has the value <pre>bar</pre> at the time the template is requested,
    <pre>bar</pre> replaces all instances of <pre>$foo</pre> on the web 
    page. Alternatively, if I include the statement
 </p>
    
 <p>
    <source><![CDATA[
    #set $foo = "bar"
    ]]></source>
 </p>
    
 <p>
    the output will be the same for all instances of <pre>$foo</pre>
    that follow this directive.
 </p>
  
 <p>
 <strong>Properties</strong>
 <br/>
    The second flavor of VTL references are properties, and properties have
    a distinctive format. The shorthand notation consists of a leading "$"
    character followed a VTL Identifier, followed by
    a dot character (".") and another VTL Identifier.
    These are examples of valid property references in the VTL:
 </p>
 
 <p>
    <source><![CDATA[
    $customer.Address
    $purchase.Total
    ]]></source>
 </p>   

 <p>
    Take the first example, <pre>$customer.Address</pre>. It can 
    have two meanings. It can mean,
    Look in the hashtable identified as <pre>customer</pre> and return the
    value associated with the key <pre>Address</pre>. But
    <pre>$customer.Address</pre> can also be referring to a method (references 
    that refer to methods will be discussed
    in the next section); <pre>$customer.Address</pre> could be an 
    abbreviated way of writing <pre>$customer.getAddress()</pre>. 
    When your page is requested, Velocity will determine which of these 
    two possibilities makes sense, and then return the appropriate value.
 </p>

 <p>
 <strong>Methods</strong>
 <br/>
    A method is defined in the Java code and is capable of doing something
    useful, like running a calculation or arriving at a decision.
    Methods are references that consist of a leading "$"
    character followed a VTL Identifier, followed
    by a VTL <em>Method Body</em>. A VTL Method Body
    consists of a VTL Identifier followed by an
    left parenthesis character ("("), followed by an optional parameter
    list, followed by right parenthesis character (")").
    These are examples of valid method references in the
    VTL:
 </p>
 
 <p>
    <source><![CDATA[
    $customer.getAddress()
    $purchase.getTotal()
    $page.setTitle("My Home Page")
    $person.setAttributes("Strange", "Weird", "Excited")
    ]]></source>
 </p>  

 <p>
    The first two examples -- 
    <pre>$customer.getAddress()</pre> and <pre>$purchase.getTotal()</pre> 
    -- may look similiar to those used in the Properties section above,
    <pre>$customer.Address</pre>
    and <pre>$purchase.Total</pre>. If you guessed that these examples must
    be related some in some fashion, you are correct! 
 </p>
 
 <p>
    VTL Properties can be used as a shorthand notation for VTL Methods. The
    Property $customer.Address has the exact same effect as
    using the Method $customer.getAddress(). It is generally preferable
    to use a Property when available. The main difference between Properties
    and Methods is that you can specify a parameter list to a Method.
 </p>

 <p>
    The shorthand notation can be used for the following Methods
 </p>

 <p>
    <source><![CDATA[
    $sun.getPlanets()
    $annelid.getDirt()
    $album.getPhoto()
    ]]></source>
 </p>
 
 <p>
    We might expect these methods to return the names of planets belonging to 
    the sun, feed our earthworm, or get a photograph from an album. Only the 
    long notation works for the following Methods.
 </p>
 
 <p>
    <source><![CDATA[
    $sun.getPlanet("Earth", "Mars", "Neptune") 
    ## Can't pass a parameter list with $sun.Planets

    $sisyphus.pushRock()
    ## Velocity assumes I mean $sisyphus.getRock() 
    
    $book.setTitle("Homage to Catalonia")
    ## Can't pass a parameter list
    ]]></source>
 </p>

 <p>
    <strong>Formal Reference Notation</strong>
    <br/>
    Shorthand notation for
    references was used for the examples listed above, but there is 
    also a formal notation for references, which is demonstrated below:
 </p>
 
 <p>
    <source><![CDATA[
    ${mudSlinger}
    ${customer.Address}
    ${purchase.getTotal()}
    ]]></source>
 </p>
 
 <p>
    In almost all cases you will use the shorthand notation
    for references, but in some cases the formal
    notation is required for correct processing. 
 </p>
    
 <p>
    Suppose you were
    constructing a sentence on the fly where $vice was to be
    used as the base word in the noun of a sentence. Suppose you
    wanted to allow someone to choose the base word and produce
    one of the two following results: "Jack is a pyromaniac." or
    "Jack is a kleptomaniac.". Using shorthand notation would
    produce the following:
 </p>
 
 <p>
    <source><![CDATA[
    Jack is a $vicemaniac.
    ]]></source>
 </p>
 
 <p>
    There is ambiguity here, and Velocity assumes that $vicemaniac,
    not $vice, is the Identifer that you mean to use. Finding no
    value for $vicemaniac, it will return <pre>$vicemaniac</pre>.
    Using formal notation can resolve this problem.
 </p>
 
 <p>
    <source><![CDATA[
    Jack is a ${vice}maniac.
    ]]></source>
 </p>
 
 <p>
    Now Velocity knows that $vice, not $vicemaniac, is your
    Identifier. Formal notation is often useful when references
    are directly adjacent to text in your templates.
 </p>


 <p>
    <strong>Quiet Reference Notation</strong>
    <br/>
    When Velocity encounters a reference that is undefined,
    its normal behavior is to output the image
    of the reference. For example, suppose the following
    reference appears as part of a VTL template.
 </p>
 
 <p>
    <source><![CDATA[
    <input type="text" name="email" value="$email"/>
    ]]></source>
 </p>
 
 <p>
    When the form initially loads, the variable
    reference <pre>$email</pre> has no value, but you prefer the
    a blank text field to one with a value of "$email".
    Using the quiet reference notation circumvents Velocity's
    normal behavior; instead of using $email in the
    VTL you would use $!email. So the above example
    would look like the following:
 </p>
 
 <p>
    <source><![CDATA[
    <input type="text" name="email" value="$!email"/>
    ]]></source>
 </p>
 
 <p>
    Now when the form is initially loaded and
    $email still has no value, an empty string will
    be output instead of "$email".
 </p>

 <p>
    Formal and quiet reference notation can be used together,
    as demonstrated below.
 </p>
 
 <p>
    <source><![CDATA[
    <input type="text" name="email" value="$!{email}"/>
    ]]></source>
 </p>
 
</s1>

<s1 title="Getting literal">

  <p>
    VTL uses special characters, such as $ and #, to do its work, so some
    added care should be taken where using these characters in your 
    templates.
  </p>
 
  <p>
    <strong>Currency</strong>
    <br/>
    There is no problem writing "I bought a 4 lb. sack of 
    potatoes at the farmer's market for only $2.50!" As mentioned, a VTL
    identifier always begins with an upper- or lowercase letter, so
    $2.50 would not be mistaken for a reference.
  </p>
  
  <p>
    <strong>Escaping special characters</strong>
    <br/>
    Other cases may arise, however, where there is the potential for Velocity
    to get confused. <em>Escaping</em> special characters is the best way
    to handle VTL's special characters in your templates, and this can be
    done using the backslash ("\") character.
  </p>
  
  <p>
    If Velocity encounters in your VTL template a reference to 
    <pre>$email</pre>, it will search for a corresponding value, but
    when the escape character is used, <pre>$email</pre> is treated
    as ordinary text
  </p>
  
  <p>
    <source><![CDATA[
    \$email
    ]]></source>
  </p>
 
  <p>
    Velocity treats <pre>$</pre> as a literal rather than a special 
    character, <pre>$email</pre> as text rather than a reference, 
    and doesn't even attempt to find a corresponding value.
  </p>
 
  <p>
    And what if -- for instance you are writing documentation for
    the Windows platform -- and you want to print a backslash character?
    Just escape one backslash character with another, as shown:
  </p>
  
  <p>
    <source><![CDATA[
    c:\\winnt\\system32
    ]]></source>
  </p>
</s1>

<s1 title="Summary: References">
    
    <p>
    Now that you are familiar with references, you can begin to
    apply them effectively in your templates.
    Velocity references take advantage of some Java principles that 
    template designers will find easy to use. For example:
    </p>

    <p>
    <source><![CDATA[
    $foo
    
    $foo.getBar() 
    ## is the same as 
    $foo.Bar
    
    $data.getUser("jon")
    ## is the same as 
    $data.User("jon")
    
    
    $data.getRequest().getServerName()
    ## is the same as 
    $data.Request.ServerName
    ## is the same as 
    ${data.Request.ServerName}
    ]]></source>
    </p>

    <p>
    These examples illustrate alternative uses for the same references. 
    Velocity takes advantage of Java's introspection and 
    bean features to resolve the reference names to both objects in the Context 
    as well as the objects methods. It is possible to embed and evaluate 
    references almost anywhere in your template.
    </p>
    
</s1>


<s1 title="Directives">  
 
 <p>
    References allow template designers to generate dynamic content for
    web sites, while <em>directives</em> -- easy to use 
    script elements that can be used to creatively manipulate the output of 
    Java code -- permit web designers to truly take charge 
    of the appearance and content of the web site.
 </p>

 <p>
    <strong>#set</strong>
    <br/>
    The #set directive is used for setting the value of
    a reference. A value can be assigned to either a variable
    reference or a property reference:
 </p>
 
 <p>
    <source><![CDATA[
    #set $primate = "monkey"
    #set $customer.Behavior = $primate
    ]]></source>
 </p>
 
 <p>
    The left hand side (LHS) of the assigment must be
    a variable reference or a property reference. The
    right hand side (RHS) can be one of the following
    types:
 </p>
 
 <p>
    <ul>
        <li>Variable reference</li>
        <li>String literal</li>
        <li>Property reference</li>
        <li>Method reference</li>
        <li>Number literal</li>
        <li>Object array</li>
    </ul>
 </p>
 
 <p>
    These examples demonstrate each of the aforementioned 
    types:
 </p>
 
 <p>
    <source><![CDATA[
    #set $monkey = $bill ##variable reference
    #set $monkey.Friend = "monica" ##string literal
    #set $monkey.Blame = $whitehouse.Leak ##property reference
    #set $monkey.Plan = $spindoctor.weave($web) ##method reference
    #set $monkey.Number = 123 ##number literal
    #set $monkey.Say = ["Not", $my, "fault"] ##object array
    ]]></source>
 </p>
 
 <p>
    The RHS can also be a simple arithmetic expression:
 </p>
 
 <p>
    <source><![CDATA[
    #set $value = $foo + 1
    #set $value = $bar - 1
    #set $value = $foo * $bar
    #set $value = $foo / $bar
    ]]></source>
 </p>

<s1 title="Conditionals">

    <strong>If / ElseIf / Else</strong>
    <p>
       The #if statement in Velocity allows for text to be 
       included when the web page is generated, on the conditional 
       that the if statement is true. For example:
    </p>

    <p>
      <source><![CDATA[
      #if ($foo)
         <strong>Velocity!</strong>
      #end
      ]]></source>
    </p>

    <p>
      The variable $foo is evaluated to see if it is true, which will happen 
      under one of two circumstances: (i) $foo is a boolean (true/false) which 
      has a true value, or (ii) the value is not null. The content between the 
      <pre>#if</pre> and the <pre>#end</pre> statements become the output if 
      the evaluation is true. In this case, if <pre>$foo</pre> is true, the
      output will be: "Velocity!". Conversely, if <pre>$foo</pre> has a null 
      value, or if it is a boolean false, the statement evaluates as false, and
      there is no output.
    </p>
    
    <p>
      An #elseif or #else element can be used with an #if element.
    </p>

    <p>
    <source><![CDATA[
    #if ($foo)
        <strong>Velocity Rocks!</strong>
    #elseif ($bar)
        <strong>Velocity Rocks Again!</strong>
    #else
        <strong>Velocity Still Rocks!</strong>
    #end
    ]]></source>
    </p>
    
    <p>
    In this example, if $foo is false, then the output will be
    <strong>Velocity Still Rocks!</strong> 
    </p>

    <p>
      Logical operators are not yet available in Velocity. This functionality is 
      expected to be added soon. An unexplained example of a logical operator is 
      shown below.
    </p>

    <p>
      <source><![CDATA[
      #if ($foo && $bar)
         <strong>Velocity Rocks!</strong>
      #end
      ]]></source>
    </p>
 </s1>

 <s1 title="Loops">
    <strong>Foreach Loop</strong>
    <p>
    The #foreach element allows for looping. For example:
    </p>

    <p>
    <source><![CDATA[
    <ul>
    #foreach ($product in $allProducts)
        <li>$product</li>
    #end
    </ul>
    ]]></source>
    </p>

    <p>
    This #foreach loop causes the $allProducts list (the object) to be 
    looped over for all of the products (targets) in the list. Each time 
    through the loop, the value from $allProducts is placed into the 
    $product variable.
    </p>
    
    <p>
    The contents of the $allProducts variable is either a Vector, a Hashtable 
    or an Array. The value assigned to the $product variable is a Java
    Object and can be referenced from a variable as such. For example, if 
    $product was really a Product class in Java, its name could be retrieved
    by referencing the $product.Name method (ie: Product.getName()).
    </p>

 </s1>    

 <s1 title="Include">
    <p>
    The #include script element allows the template designer to import a 
    local file, which is then inserted into the location where the #include 
    directive is defined. The contents of the file are not rendered through 
    the template engine.
    </p>
    
    <p>
    <source><![CDATA[
    #include /path/to/file.vm
    ]]></source>
    </p>
 </s1>



 <s1 title="Stop">
    <p>
    The #stop script element allows the template designer to stop the execution
    of the template engine and return. This is useful for debugging purposes.
    </p>
    
    <p>
    <source><![CDATA[
    #stop
    ]]></source>
    </p>    
 </s1>

 <s1 title="Macro">
    <p>
    With the #macro script element, the template designer can define a 
    time-saving macro. 
    </p>    
    
    <p>
    <source><![CDATA[
    #macro (row $content) <tr><td>$content</td></tr> #end
    ]]></source>
    </p>
    
    <p>
    This establishes a macro called "row", which uses HTML tags to
    put content into its own table data cell in an HTML table. Having 
    defined the #row macro, the template designer can now call the #row 
    macro by name.
    </p>
    
    <p>
    <source><![CDATA[
    <table>
    #foreach ($element in $list)
	#row ($element)
    #end
    </table>
    ]]></source>
    </p>
    
    <p>
    Here a newly created #row macro is nested inside a #foreach
    statement. As the #foreach statement loops through each $element
    target in the $list object, the #row macro will take the value of
    $element and put it into its table data cell.
    </p>
    
 </s1>

</s1>

</body>
</document>
