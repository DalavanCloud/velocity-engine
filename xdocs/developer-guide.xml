<?xml version="1.0"?>

<document>

 <header>
  <title>Developer's Guide</title>
  <subtitle>or How I Learned to Love the Context</subtitle>
  <authors>
   <person name="Velocity Documentation Team" email="geirm@apache.org"/>
  </authors>
 </header>

<body>

<s1 title="Introduction">
<p>
Velocity is a Java-based template engine, a simple and powerful development tool that allows you to easily create and render
documents that format and present your data.
In this guide, we hope to give an overview of the basics of development using Velocity, focusing on the two main areas for Velocity usage :

<ul>
<li> servlet-based WWW development</li>
<li> general application use</li>
</ul>

You will see that there is no real difference between these, other than we make servlet development with Velocity very easy
if you use our provided class VelocityServlet as a base class for your servlet.
</p>
</s1>

<s1 title="Resources">
<p>
There are quite a few resources and examples available to the programmer, and we recommend that you look at our examples, documentation and even the source code.  They are found in 

<ul>
<li> source code : /src/java/...</li>
<li> general examples : /examples </li>
<li> Anakia application :  example application showing how to use Velocity for creating stylesheet renderings of xml data 
- /examples/anakia </li>
<li> Forumdemo web app : working example of a simple servlet-based forum application - /examples/forumdemo</li>
<li> documentation : /docs</li>
<li> templates : for the designer, we have a large collection of template examples in our testbed directory - /test/templates</li>
</ul>

All directory references above are relative to the distribution root directory.
</p>
</s1>

<s1 title="The Fundamental Code Pattern">
<p>
When using Velocity in an application program or in a servlet (or anywhere, actually), you will generally do the following :

<ol>
<li>Create a Context object (more on what that is later).</li>
<li>Add your data objects to the Context.</li>
<li>Choose a template.</li>
<li>'Merge' the template and your data to produce the ouput.</li>
</ol>

In code, this looks like 

<source><![CDATA[
import java.io.StringWriter;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.runtime.Runtime;

VelocityContext context = new VelocityContext();

context.put( "name", new String("Velocity") );

Template template = null;

try
{
   template = Runtime.getTemplate("mytemplate.vm");
}
catch( Exception e )
{}

StringWriter sw = new StringWriter();

template.merge( context, sw );

]]></source>
</p>
<p>
Thats the basic pattern.  It is very simple, isn't it?
</p>
</s1>

<s1 title="The Context">
<strong>The Basics</strong>
<p>
The concept of the 'context' is central to Velocity, and is a common technique for moving a container of data around between 
parts of a system.  The idea is that the context is a 'carrier'
of data between the Java layer (or you the programmer) and the template layer ( or the designer ).  You as the programmer will 
gather objects of various types, whatever your application calls for, and place them in the context.  To the designer, these 
objects, and their methods and properties, will become accessable via template elements called 
<link href='vtl-reference-guide.html'> references</link>.  Generally, you will work with the designer to determine the data 
needs for the application, and the 'API' that you are in a way creating as you produce a data set for the designer to access
in the template.
</p>

<p>
While Velocity allows you to create your own context classes to support special needs and techniques (like a context that
accesses an LDAP server directly, for example), a good basic implementation class called VelocityContext is provided for you 
as part of the distribution.
</p>
<p>
VelocityContext is suitable for all general purpose needs, and we strongly recommended that you use it. Only in exceptional
and advanced cases will you need to extend or create your own context implementation.  
</p>
<p>
Using VelocityContext is as simple as using a normal Java Hashtable class.  While the interface contains other useful methods, 
the two main methods you will use are

<source><![CDATA[
 public Object put(String key, Object value);
 public Object get(String key);
]]></source>

Please note that like a Hashtable, the value must be derived from java.lang.Object, and must not be null.  
Fundamental types like int or float must be wrapped in the appropriate wrapper classes.
</p>
<p>
That's really all there is to basic context operations.  For more information, see the API documentation included in the distribution.
</p>

<strong>Context Chaining</strong>
<p>
An innovative feature of Velocity's context design is the concept of <i>context chaining</i>.  
Also sometimes referred to as <i>context wrapping</i>, this advanced feature allows you to connect separate contexts together in a
manner that makes it appear as one 'contiguous' context to the template.
</p>
<p>
This is best illustrated by an example :
<source><![CDATA[
 VelocityContext context1 = new VelocityContext();
 
 context1.put("name","Velocity");
 context1.put("project", "Jakarta");
 context1.put("duplicate", "I am in context1");

 VelocityContext context2 = new VelocityContext( context1 );

 context2.put("lang", "Java" );
 context2.put("duplicate", "I am in context2");

 template.merge( context2, writer );

]]></source>

In the code above, we have set up context2 such that it <i>chains</i> context1.  This means that in the template, 
you can access any of 
the items that were put into either of the two VelocityContext objects, as long as there is no duplication of the keys
used to add objects.  If that is the case, as it is above for the key 'duplicate', the object stored in the nearest 
context in the chain will be available.  In this example above, the object returned would be the string "I am in context2".
</p>
<p>
Note that this duplication, or 'covering', of a context item does not in any way harm or alter the covered object.  So in the example above, the string "I am in context1" is alive and well, still accessable via context1.get("duplicate").  But in the example
above, the value of the reference '$duplicate' in the template would be 'I am in context2', and the template has no access to 
the covered string 'I am in context1'.
</p>
<p>
This feature has many uses, the most common so far is providing layered data access and toolsets.
</p>
<p>
As mentioned before, the Velocity context mechanism is also extendable, but beyond the current scope of this guide.
If you are interested, please see the classes in the package
org.apache.velocity.context to see how the provided contexts are put together.  Futher, there are a few examples in the examples
directory in the distribution which show alternate implementations, including [a goofy] one 
that uses a database as the backing storage. 
</p>
<p>
Please note that these examples are unsupported and are there for demonstration/educational purposes only.
</p>

</s1>

<s1 title="Using Velocity In Servlets">
<strong>Programming</strong>
<p>
The most common use of Velocity is in the area of Java Servlet programming for the WWW.  There are many reasons why Velocity is
well suited for this task, one of the primary ones is Velocity's enforcement of the separation of the presentation (or view) layer from 
the code layer.  There are many resources on this subject, including <link href='http://www.javaworld.com/javaworld/jw-12-1999/jw-12-ssj-jspmvc.html'>this</link>.  
</p>
<p>
The basic technique of using Velocity in a servlet environment is very simple.  In a nutshell, all you must do is 
extend the provided VelocityServlet base class and implement a single method handleRequest().  That's really all that is required 
to use Velocity in your servlet development.
</p>
<p>
The following code is similar to the 
SampleServlet.java class included in the distribution in the examples directory.

<source><![CDATA[
public class SampleServlet extends VelocityServlet
{
    public Template handleRequest( Context context )
    {
        Template template = null;
        
        String p1 = "Jakarta";
        String p2 = "Velocity";
        
        Vector vec = new Vector();
        vec.addElement( p1 );
        vec.addElement( p2 );

        context.put("list", vec );
        
        try
        {
            template =  getTemplate("sample.vm");
        }
        catch( Exception e )
        {}

        return template;
    }
}
]]></source>

</p>
<p>
Look familiar?  With the exception of creating the context object, which is done for you by the VelocityServlet base class,
 and  the  merge() step which is also done for you by the VelocityServlet base class, 
it's identical to the basic code pattern we mentioned at the beginning of this guide.  
We take the context, add our application data, and return a template. 
</p>
<strong>Deployment</strong>
<p>
When you deploy your Velocity-based servlets, you will certainly want to ensure that your properties file is used to configure
the Velocity runtime.  Under Tomcat, one way to accomplish this is by placing your velocity.properties file into the root 
directory of your web app (webapps/appname ) and then add the following to your WEB-INF/web.xml file :
<source><![CDATA[
<servlet>
  <servlet-name>MyServlet</servlet-name>
  <servlet-class>com.foo.bar.MyServlet</servlet-class>
  <init-param>
      <param-name>properties</param-name>
      <param-value>velocity.properties</param-value>
  </init-param>
</servlet>
]]></source>

Assuming all is right, this will ensure that when MyServlet is loaded, it will use the velocity.properties file to initialize itself
rather than relying on it's internal defaults.
</p>
<p>
Note that Velocity uses a singleton model for it's central core Runtime class, so it is a very good idea to put the velocity-XX.jar
into the WEB-INF/lib directory in all web applications that use Velocity to ensure that the web app classloader is 
managing your Runtime instance,
rather than putting it in the CLASSPATH or the top level lib directory of the servlet runner. 
</p>
<p>
This deployment method will ensure that different web applications will not be subject to Velocity configuration conflicts.
</p>
</s1>

<s1 title="Velocity Properties">
<p>
Velocity's runtime configuration is controlled by regular Java properties.  There is a set of default properties contained
 in Velocity's jar, found in
/src/java/org/apache/velocity/runtime/defaults/velocity.defaults, that Velocity uses as it's configuration baseline.  This ensures that Velocity will always have a 'correct' value
for it's configuration and startup, although it may not be what you want. 
</p>
<p>  Any properties then specified at init() time will replace the  default values.  Therefore, you only have to
configure velocity with the properties that you need to change, and not worry about the rest.  Further, as we add more 
features and configuration capability, you don't have to change your configuration files to suit - the Velocity engine will
 always have default values.
</p>

<p>
Below are listed the properties that control Velocity's behavior.  Organized by category, each property is listed with it's current default value 
to the right of the '=' sign.
</p>

<strong>Runtime Log</strong>
<p>
<code>runtime.log = velocity.log</code><br/>
 Full path and name of log file for error, warning, 
and informational messages.  The location, if not absolute, is relative to the 'current directory'.
</p>

<p>
<code>runtime.log.error.stacktrace = false</code><br/>
<code>runtime.log.warn.stacktrace = false</code><br/>
<code>runtime.log.info.stacktrace = false</code><br/>
 Turns on stacktracing for the three error categories.  These produce a large 
amount of log output.
</p>

<strong>Encoding and Content Type</strong>
<p>
<code>template.encoding = 8859_1</code><br/>
 Encoding scheme to use.  Currently used in VelocityServlet.
</p>

<p>
<code>default.contentType = text/html</code><br/>
Content type, currently used in VelocityServlet.
</p>

<strong> #foreach() Directive </strong>

<p>
<code>counter.name = velocityCount</code><br/>
Used in the #foreach() directive, defines the string to be used as the context key for the loop count. A template would access
the loop count as $velocityCount.
</p>

<p>
<code>counter.initial.value = 1</code><br/>
Default starting value for the loop counter reference in a #foreach() loop.
</p>

<strong> #include() and #parse() Directive </strong>
<p>
<code>include.output.errormsg.start = <![CDATA[ <!-- include error : ]]> </code><br/>
<code>include.output.errormsg.end   =  <![CDATA[ see error log --> ]]></code><br/>
Defines the beginning and ending tags for an in-stream error message in the case of a problem with the #include() directive.
If both the .start and .end tags are defined, an error message will be output to the stream, of the form '.start msg .end' where .start and .end refer to the property values.  
Output to the render stream will only occur if both the .start and .end (next) tag are defined. 
</p>
<p>
<code>parse_directive.maxdepth = 10</code><br/>
Defines the allowable parse depth for a template. A template may #parse() another template which itself may have a #parse() directive.  This value prevents runaway #parse() recursion.
</p>

<strong> Resource Management </strong>
<p>
<code>resource.loader.1.public.name = File</code><br/>
Pulic name of the file resource loader, to allow application software to alter propertes 
of a loader by name rather than the 'load number',
the integer following 'loader'.  This allows the administration of resource loaders to be decoupled from the application uses.
</p>
<p>
<code>resource.loader.1.description = Velocity File Resource Loader</code><br/>
Description string for the loader.
</p>
<p>
<code>resource.loader.1.class = org.apache.velocity.runtime.resource.loader.FileResourceLoader</code><br/>
Name of implementation class for the loader.  The default loader is the file loader.
</p>
<p>
<code>resource.loader.1.resource.path = .</code><br/>
Root from which the file loader loads templates. Templates may live in subdirectories of this root.  ex. homesite/index.vm
</p>
<p>
<code>resource.loader.1.cache = false</code><br/>
Controls caching of the templates in the loader.  Default is false, to make life easy for development and debugging.  This should
be set to true for production deployment.
</p>
<p>
<code>resource.loader.1.modificationCheckInterval = 2</code><br/>
</p>

<strong>Velocimacro</strong>

<p>
<code>velocimacro.library.global = VM_global_library.vm </code><br/>
Name of one of two default libraries of VMs to be loaded when the Velocity Runtime engine starts.  These VMs are accessable to all 
templates.  The file is assumed to be relative to the root of the file loader resource path.
</p>

<p>
<code>velocimacro.library.local = [no default value] </code><br/>
The 'other' default library of VMs to be loaded when the Velocity Runtime engine starts.  These VMs are accessable to all 
templates.  The file is assumed to be relative to the root of the file loader resource path.
</p>

<p>
<code>velocimacro.permissions.allowInline = true</code><br/>
Determines of the definition of new VMs via the #macro() directive in templates is allowed.  The default value is true, meaning any
template can define and use new VMs.  Note that depending on other properties, those #macro() statements can replace global
definitions.
</p>
<p>
<code>velocimacro.permissions.allowInlineToReplaceGlobal = false </code><br/>
</p>

<p>
<code>velocimacro.permissions.allowInlineLocalScope = false</code><br/>
Controls 'private' templates namespaces for VMs.  When true, a #macro() directive in a template creates a VM that is accessable
only from the defining template.  This means that VMs cannot be shared unless they are in the global or local library loaded 
at startup. (See above.)  It also means that templates cannot interfere with each other.  This property also allows a technique
where there is a 'default' VM definition in the global or local library, and a template can 'override' the implementation for 
use within that template.  This occurrs because when this property is true, the template's namespace is searched for a VM before
the global namespace, therefore allowing the override mechanism.
</p>
<p>
<code>velocimacro.context.localscope = false</code><br/>
Controls whether reference access (set/get) within a Velocimacro will change the context, or be of local scope in that 
VM.
</p>

<strong>References</strong>

<p>
<code>runtime.log.reference.log_invalid = true </code><br/>
Property to turn off the log output when a reference isn't valid.  Good thing to turn of in production, but very valuable
for debugging.
</p>

<strong>String Interpolation</strong>

<p>
<code>stringliterals.interpolate = true</code><br/>
Controls interpolation mechanism of VTL String Literals.  Note that a VTL StringLiteral is specifically a string using double quotes that is used in a #set() statement, a method call of a reference, a parameter to a VM, or as an argument to a VTL directive in general.  See the VTL reference for further information.
</p>
</s1>

<s1 title="Summary">

<p>
We hope this brief guide was a helpful introduction to using Velocity in your Java projects, and thank you for you interest
in Velocity.  We welcome any and all comments
you may have about this documentation and the Velocity template engine itself.  
</p>
<p>
Please submit all detailed, thoughtful and constructive feedback through our 
<link href="http://jakarta.apache.org/getinvolved/mail.html">mail lists</link>.
</p>
</s1>
</body>
</document>