<?xml version="1.0"?>

<document>

 <header>
  <title>VTL Reference Guide</title>
  <subtitle>VTL Refernce Guide</subtitle>
  <authors>
   <person name="Jason van Zyl" email="jvanzyl@apache.org"/>
   <person name="John Castura" email="jcastura@apache.org"/>
  </authors>
 </header>

<body>

<!--

Some of the user's guide info should be moved into
this reference guide and links should be made from
the user's guide to this document

I now envision the user guide to be pedagogical 
in nature and the VTL guide to be a distillation of VTL for
expert users and fast learners. I'd like each directive to
have an identical format. -JC

-->

<s1 title="About this Guide">

<p>
    This guide is the definitive but imcomplete reference for
    the Velocity Template Language (VTL). For more information,
    please refer to the Velocity User Guide.
</p> 

</s1>

<s1 title="References">

<p>
    There are three types of references in the VTL: variables, properties
    and methods. As a designer using the VTL, you and your engineers must 
    come to an agreement on the specific names of references so
    you can use them correctly in your templates.
</p>

<p>
    <strong>Variables</strong>
    <br/>
    The shorthand notation of a variable consists of a leading <vtl>$</vtl> character
    followed by a VTL <em>Identifier</em>. A VTL Identifier must
    start with an alphabetic character (a .. z or A .. Z); the rest of the
    characters are limited to the following types of characters: alphabetic,
    numeric (0 .. 9), hyphen ("-"), and underscore ("_").
    Here are examples of valid variable references in the VTL:   
</p>

<p>
    <source><![CDATA[
    $mudSlinger
    $mud-slinger
    $mud_slinger
    $mudSlinger1
    ]]></source>
</p>

<p>
    <strong>Properties</strong>
    <br/>
    Properties are references that consist of a leading <vtl>$</vtl>
    character followed a VTL Identifier, followed by
    a dot character (".") and another VTL Identifier. 
    These are examples of valid property references in the VTL:
</p>

<p>
    <source><![CDATA[
    $customer.Address
    $purchase.Total
    ]]></source>
</p>

<p>
    <strong>Methods</strong>
    <br/>
    Methods are references that consist of a leading <vtl>$</vtl>
    character followed a VTL Identifier, followed
    by a VTL <em>Method Body</em>. A VTL Method Body
    consists of a VTL Identifier followed by a
    left parenthesis character ("("), followed by an optional parameter
    list, followed by right parenthesis character (")").
    Examples of valid method references in the
    VTL are shown below:
</p>

<p>
    <source><![CDATA[
    $customer.getAddress()
    $purchase.getTotal()
    $page.setTitle( "My Home Page" )
    $person.setAttributes( "Strange","Weird","Excited" )
    ]]></source>
</p>

<p>
    VTL Properties can be used as a shorthand notation 
    for VTL Methods that take <vtl>get</vtl> and <vtl>set</vtl>.
    <vtl>$object.getMethod()</vtl> or <vtl>$object.setMethod()</vtl>
    can be abbreviated as <vtl>$object.Method</vtl>.
</p>

<p>
    It is generally preferable to use a Property when available. The 
    main difference between Properties and Methods is that you can 
    specify a parameter list to a Method.
</p>

<p>
    <strong>Formal Reference Notation</strong>
    <br/>
    In the examples listed above the shorthand notation for
    references was used, but there is a formal notation that
    looks like the following:
</p>

<p>
    <source><![CDATA[
    ${mudSlinger}
    ${customer.Address}
    ${purchase.getTotal()}
    ]]></source>
</p>

<p>
    Shorthand notation is usually used for references, but formal
    reference notation is required for correct processing when 
    the identifier would otherwise be adjacent to text. In the
    following example, Velocity would determine the reference
    to be <vtl>$vicemaniac</vtl> were shorthand reference notation
    used.
</p>

<p>
    <source><![CDATA[
    Jack is a ${vice}maniac.
    ]]></source>
</p>


<p>
    <strong>Quiet Reference Notation</strong>
    <br/>
    When Velocity encounters an undefined reference,
    it outputs the image of the reference. For example, if
    <vtl>$reference</vtl> is undefined, the output will be
    <vtl>$reference</vtl>. Quiet reference notation can be 
    used to suppress this output, and is denoted with a 
    <vtl>!</vtl> after the <vtl>$</vtl> character; for
    example, the quiet notation for <vtl>$reference</vtl>
    is <vtl>$!reference</vtl> if shorthand notation is used,
    and <vtl>$!{reference}</vtl> if formal notation is used.
</p>

</s1>

<s1 title="Directives">
<p>        
    <strong>#set</strong>
    <br/>
    The <vtl>#set</vtl> directive is used to set the value of 
    a reference. 
</p>

<p>
    <source><![CDATA[
    #set( $ref = arg )
    ]]></source>
</p>

<p>
    <vtl>$ref</vtl> - The LHS of the assignment must be
    a variable reference or a property reference. 
</p>

<p>
    <vtl>arg</vtl> - The RHS is limited to the following
    types:
    <ul>
        <li>Variable reference</li>
        <li>String literal</li>
        <li>Property reference</li>
        <li>Method reference</li>
        <li>Number literal</li>
        <li>Object array</li>
    </ul>        
</p>

<p>
    Here are examples demonstrating the 
    aforementioned types:
</p>

<p>
    <source><![CDATA[
    #set( $monkey = $bill )
    #set( $monkey.Friend = "monica" )
    #set( $monkey.Blame = $whitehouse.Leak )
    #set( $monkey.Plan = $spindoctor.weave($web) )
    #set( $monkey.Number = 123 )
    #set( $monkey.Say = ["Not", $my, "fault"] )
    ]]></source>
</p>

<p>
    The RHS can also be a simple arithmetic expression:
</p>    

<p>
    <source><![CDATA[
    #set( $value = $foo + 1 )
    #set( $value = $bar - 1 )
    #set( $value = $foo * $bar )
    #set( $value = $foo / $bar )
    ]]></source>
</p>


<p>        
    <strong>#foreach</strong>
    <br/>
    The <vtl>#foreach</vtl> directive provides a simple way 
    of looping through a list of objects.
</p>

<p>
    <source><![CDATA[
    <table>
    #foreach( $customer in $customerList )
        <tr>
          <td>
            $customer.Name
          </td>
        </tr>
    #end        
    ]]></source>
</p>

<p>
    Velocity provides an easy way to get the loop
    counter so that you can do something like the
    following:
</p>
    
<p>    
    <source><![CDATA[
    <table>
    #foreach( $customer in $customerList )
        <tr>
          <td>
            $velocityCounter
          </td>
          <td>
            $customer.Name
          </td>
        </tr>
    #end        
    ]]></source>
</p>

<p>
    The default name for the loop counter variable
    reference, which is specified in the velocity.properties
    file, is $velocityCount. By default the counter starts
    at 1, but this can be set to either 0 or 1 in the 
    velocity.properties file. Here's what the loop counter 
    properties section of the velocity.properties file appears:
</p>    

<p>    
    <source><![CDATA[
    # Default name of the loop counter
    # variable refernce.
y    counter.name = velocityCount
    
    # Default starting value of the loop
    # counter variable reference.
    counter.initial.value = 1
    ]]></source>
</p>

 <strong>#parse</strong>
    <p>
    The <vtldirective>#parse</vtldirective> script element allows the template designer to import a 
    local file that contains VTL. Velocity will parse the VTL and render the template specified.
    </p>

    <p>
    <source><![CDATA[
    #parse( "me.vm" )
    ]]></source>
    </p>

    <p>
    Like the <vtldirective>#include</vtldirective> directive, <vtldirective>#parse</vtldirective> 
    can take a variable rather than a template. Any templates to which <vtldirective>#parse</vtldirective> 
    refers must be included under TEMPLATE_ROOT. Unlike the <vtldirective>#include</vtldirective> directive, 
    <vtldirective>#parse</vtldirective> will only take a single argument. 
    </p>

    <p>
    VTL templates can have <vtldirective>#parse</vtldirective> statements referring to templates that in turn 
    have <vtldirective>#parse</vtldirective> statements. By default set to 10, the <vtl>parse_directive.maxdepth</vtl> 
    line of the <filename>velocity.properties</filename> allows users to customize maximum number of 
    <vtldirective>#parse</vtldirective> referrals that can occur from a single 
    template. (Note: If the <vtl>parse_directive.maxdepth</vtl> property is absent from the 
    <filename>velocity.properties</filename> file, Velocity will set this default to 10.)  
    Recursion is permitted, for example, if the template <filename>dofoo.vm</filename> contains the following lines:
    </p>

    <p>
    <source><![CDATA[
    Count down.
    #set( $count = 8 )
    #parse( "parsefoo.vm" )
    All done with dofoo.vm!
    ]]></source>
    </p>    
    
    <p>
    It would reference the template <filename>parsefoo.vm</filename>, which might contain the following VTL:
    </p>

    <p>    
    <source><![CDATA[
    $count
    #set( $count = $count - 1 )
    #if( $count > 0 )
      #parse( "parsefoo.vm" )
    #else
      All done with parsefoo.vm!
    #end
    ]]></source>
    </p>    

    <p>
    After "Count down." is displayed, Velocity passes through <filename>parsefoo.vm</filename>, counting down from 8. 
    When the count reaches 0, it will display the "All done with parsefoo.vm!" message. At this point, Velocity will return to 
    <filename>dofoo.vm</filename> and output the "All done with dofoo.vm!" message.
    </p>


 <strong>#macro</strong>

   <p>
   A Velocimacro is defined with the <vtl>#macro</vtl> 
   directive.
   </p>

   <p>
   <source><![CDATA[
   #macro( vmname $arg1 $arg2 )
   <VM VTL code>
   #end
   ]]></source>
   </p>

   <p>
   <vtl>vmname</vtl> - The name that will be used to call the VM (<vtl>#vmname</vtl>)
   </p>

   <p>
   <vtl>$arg1 $arg2</vtl> - Arguments to the VM. A VM can have any number of argumentss,
   but the number used at invocation must match the number specified in the
   definition.
   </p>

   <p>
   <vtl>&lt;VM VTL code&gt;</vtl> - Any valid VTL code, anything you can put into a
   template, can be put into a VM.
   </p>

   <p>
   Once defined, the VM is used like any other VTL directive in your template.
   </p>

   <p>
   <source><![CDATA[
   #vmname( $arg1 $arg2 )
   ]]></source>
   </p>

   <p>
   VMs can be defined in a 'global library', a 'local library', or
   'inline' in a template.  Both global library and local libraries can be
   accessed by any template. The global library contains VMs pre-packaged 
   with Velocity; the local library allows end users to supplement the 
   pre-packaged VMs with customized, site-specific VMs. Inline VM
   definitions are those found in regular 'user' templates, although
   these can only be used when the <vtl>velocimacro.permissions.allowInline=true</vtl>
   in the <filename>velocity.properties</filename> file.
   </p>

</s1>

</body>
</document>











