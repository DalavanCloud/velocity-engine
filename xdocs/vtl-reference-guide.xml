<?xml version="1.0"?>

<document>

 <header>
  <title>VTL Reference Guide</title>
  <subtitle>VTL Refernce Guide</subtitle>
  <authors>
   <person name="Jason van Zyl" email="jvanzyl@apache.org"/>
   <person name="John Castura" email="jcastura@apache.org"/>
  </authors>
 </header>

<body>

<!--

Some of the user's guide info should be moved into
this reference guide and links should be made from
the user's guide to this document

I now envision the user guide to be pedagogical 
in nature and the VTL guide to be a distillation of VTL for
expert users and fast learners. I'd like each directive to
have an identical format. -JC

-->

<s1 title="About this Guide">

<p>
    This guide is the definitive but imcomplete reference for
    the Velocity Template Language (VTL). For more information,
    please refer to the Velocity User Guide.
</p> 

</s1>

<s1 title="References">

<p/>

    <ul>

    <li>Variables</li>
    <p/>
    Notation:
    <p/>
    <strong>$</strong> [ <strong>!</strong> ][ <strong>{</strong> ][ <strong>a..z</strong>, <strong>A..Z</strong> ][ <strong>a..z</strong>, <strong>A..Z</strong>, <strong>0..9</strong>, <strong>-</strong>, <strong>_</strong> ][ <strong>}</strong> ]
    <p/>
    Examples:<br/>
    Normal notation: <variable>$mud-Slinger_9</variable><br/>
    Silent notation: <variable>$!mud-Slinger_9</variable><br/>
    Formal notation: <variable>${mud-Slinger_9}</variable><br/>
    <p/>

    <li>Properties</li>
    <p/>
    Notation:
    <p/>
    <strong>$</strong> [ <strong>{</strong> ][ <strong>a..z</strong>, <strong>A..Z</strong> ][ <strong>a..z</strong>, <strong>A..Z</strong>, <strong>0..9</strong>, <strong>-</strong>, <strong>_</strong> ]*<strong>.</strong>[<strong>a..z</strong>, <strong>A..Z</strong> ][ <strong>a..z</strong>, <strong>A-Z</strong>, <strong>0..9</strong>, <strong>-</strong>, <strong>_</strong> ]* [ <strong>}</strong> ]
    <p/>
    Examples:
    <p/>
    Regular Notation: $customer.Address<br/>
    Formal Notation: ${purchase.Total}<br/>
    <p/>    

    <li>Methods</li>
    <p/>
    Notation:
    <p/>
    <strong>$</strong> [ <strong>{</strong> ][ <strong>a..z</strong>, <strong>A..Z</strong> ][ <strong>a..z</strong>, <strong>A..Z</strong>, <strong>0..9</strong>, <strong>-</strong>, <strong>_</strong> ]*<strong>.</strong>[ <strong>a..z</strong>, <strong>A..Z</strong> ][ <strong>a..z</strong>, <strong>A..Z</strong>, <strong>0..9</strong>, <strong>-</strong>, <strong>_</strong> ]*<strong>(</strong> [ <i>opional parameter list...</i> ] <strong>)</strong> [<strong> } </strong>]<br/>
    Examples:<br/>
    Regular Notation: $customer.getAddress()<br/>
    Formal Notation: ${purchase.getTotal()}<br/>
    Regular Notation with Parameter List: $page.setTitle( "My Home Page" )<br/>
    <p/>
    VTL Properties can be used as a shorthand notation for VTL Methods that take <vtl>get</vtl> and <vtl>set</vtl>. Either <vtl>$object.getMethod()</vtl> or <vtl>$object.setMethod()</vtl> can be abbreviated as <vtl>$object.Method</vtl>. It is generally preferable to use a Property when available. The main difference between Properties and Methods is that you can specify a parameter list to a Method.
    <p/>

    </ul>

</s1>

<s1 title="Directives">

    <p/>
    <ul>
    <li><strong>#set</strong> - Establishes the value of a reference.</li>
    <p/>
    Format:
    <p/>
    <strong>#set( $</strong>ref <strong>=</strong> [ <strong>"</strong>, <strong>'</strong> ]arg[ <strong>"</strong>, <strong>'</strong> ] )
    <p/>
    Usage:
    <br/>
    <vtl>$ref</vtl> - The LHS of the assignment must be a variable reference or a property reference.<br/>
    <vtl>arg</vtl> - The RHS of the assignment, <vtl>arg</vtl> is parsed if enclosed in double quotes, and not parsed if enclosed in single quotes. Examples of possible types are demonstrated:
    <br/>
    <ul>
        <li>Variable reference: #set( $monkey = "bill" )</li>
        <li>String literal: #set( $monkey.Friend = "monica" )</li>
        <li>Property reference: #set( $monkey.Blame = $whitehouse.Leak )</li>
        <li>Method reference: #set( $monkey.Plan = $spindoctor.weave($web) )</li>
        <li>Number literal: #set( $monkey.Number = 123 )</li>
        <li>Object array: #set( $monkey.Say = ["Not", $my, "fault"] )</li>
    </ul>
    The RHS can also be a simple arithmetic expression, such as:<br/>
        <ul>
	    <li>Addition: #set( $value = $foo + 1 )</li>
	    <li>Subtraction: #set( $value = $bar - 1 )</li>
	    <li>Multiplication: #set( $value = $foo * $bar )</li>
	    <li>Division: #set( $value = $foo / $bar )</li>
	    <li>Remainder: #set( $value = $foo % $bar )</li>
	    </ul>
    <p/>


    <li><strong>#foreach</strong> - Loops through a list of objects.</li>
    <p/>
    Format:
    <p/>
    <strong>#foreach( $</strong>ref1 <strong>in $</strong>ref2 <strong>)</strong> [ statement... ] <strong>#end</strong> 
    <p/>
    Usage:
    <br/>
    <vtl>$ref1</vtl> - The first variable reference is the item.<br/>
    <vtl>$ref2</vtl> - The second variable reference is the list that holds the items.<br/>
    <vtl>statement</vtl> - What is done each time Velocity finds a valid item ($ref1) in the list ($ref2).<br/>
    Velocity provides an easy way to get the loop counter so that you can do something like the following:<br/>   

    <source><![CDATA[ 
    <table> 
    #foreach( $customer in $customerList ) 
    <tr><td> $velocityCounter </td><td> $customer.Name </td></tr> 
    #end </table> 
    ]]></source>
    <br/>

    The default name for the loop counter variable reference, which is specified in the velocity.properties file, is $velocityCount. By default the counter starts at 1, but this can be set to either 0 or 1 in the <filename>velocity.properties</filename> file. Here's what the loop counter properties section of the <filename>velocity.properties</filename> file appears:    

<p>    
    <source><![CDATA[
    # Default name of the loop counter
    # variable refernce.
      counter.name = velocityCount
    
    # Default starting value of the loop
    # counter variable reference.
    counter.initial.value = 1
    ]]></source>
</p>

    <li><strong>#parse</strong> - Imports a local template that is parsed and rendered by Velocity.</li>
    <p/>

    Format:
    <p/>
    <strong>#parse( "</strong>template.vm<strong>" )</strong>
    <p/>
    Like the <vtldirective>#include</vtldirective> directive, <vtldirective>#parse</vtldirective> 
    can take a variable rather than a template. Any templates to which <vtldirective>#parse</vtldirective> 
    refers must be included under TEMPLATE_ROOT. Unlike the <vtldirective>#include</vtldirective> directive, 
    <vtldirective>#parse</vtldirective> will only take a single argument. 
    <p/>
    VTL templates can have <vtldirective>#parse</vtldirective> statements referring to templates that in turn 
    have <vtldirective>#parse</vtldirective> statements. By default set to 10, the <vtl>parse_directive.maxdepth</vtl> 
    line of the <filename>velocity.properties</filename> allows users to customize maximum number of 
    <vtldirective>#parse</vtldirective> referrals that can occur from a single 
    template. (Note: If the <vtl>parse_directive.maxdepth</vtl> property is absent from the 
    <filename>velocity.properties</filename> file, Velocity will set this default to 10.)  
    Recursion is permitted, for example, if the template <filename>dofoo.vm</filename> contains the following lines:

    <p>
    <source><![CDATA[
    Count down.
    #set( $count = 8 )
    #parse( "parsefoo.vm" )
    All done with dofoo.vm!
    ]]></source>
    </p>    
    
    <p>
    It would reference the template <filename>parsefoo.vm</filename>, which might contain the following VTL:
    </p>

    <p>    
    <source><![CDATA[
    $count
    #set( $count = $count - 1 )
    #if( $count > 0 )
      #parse( "parsefoo.vm" )
    #else
      All done with parsefoo.vm!
    #end
    ]]></source>
    </p>    

    <p>
    After "Count down." is displayed, Velocity passes through <filename>parsefoo.vm</filename>, counting down from 8. 
    When the count reaches 0, it will display the "All done with parsefoo.vm!" message. At this point, Velocity will return to 
    <filename>dofoo.vm</filename> and output the "All done with dofoo.vm!" message.
    </p>


    <li><strong>#macro</strong> - Allows users to define a Velocimacro (VM), a repeated segment of a VTL template, as required.</li>
    <p/>
    Format:
    <p/>   
    <strong>#macro(</strong> vmname $arg1 [ $arg2, $arg3, ... $argn ] <strong>)</strong> [ VM VTL code... ] <strong>#end</strong>
    <p/>
    <vtl>vmname</vtl> - The name that will be used to call the VM (<vtl>#vmname</vtl>)<br/>
    <vtl>$arg1 $arg2 [ ... ]</vtl> - Arguments to the VM. A VM can have any number of argumentss, but the number used at invocation must match the number specified in the definition.<br/>
    <vtl>[ VM VTL code... ]</vtl> - Any valid VTL code, anything you can put into a template, can be put into a VM.<br/>
    <p/>

   <p>
   Once defined, the VM is used like any other VTL directive in your template.
   </p>

   <p>
   <source><![CDATA[
   #vmname( $arg1 $arg2 )
   ]]></source>
   </p>

   <p>
   VMs can be defined in a 'global library', a 'local library', or
   'inline' in a template.  Both global library and local libraries can be
   accessed by any template. The global library contains VMs pre-packaged 
   with Velocity; the local library allows end users to supplement the 
   pre-packaged VMs with customized, site-specific VMs. Inline VM
   definitions are those found in regular 'user' templates, although
   these can only be used when the <vtl>velocimacro.permissions.allowInline=true</vtl>
   in the <filename>velocity.properties</filename> file.
   </p>

</ul>

</s1>

</body>
</document>











