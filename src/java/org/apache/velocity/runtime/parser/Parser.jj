/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names "The Jakarta Project", "Tomcat", and "Apache Software
 *    Foundation" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

/*
 *  NOTE : please see documentation at bottom of this file. (It was placed there its tiring
 *    to always have to page past it... :)
 */

options
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
    
    /**
     * The parser must be non-static in order for the
     * above option to work, otherwise the parser value
     * is passed in as null, which isn't all the useful ;)
     */
    STATIC=false;                                                                                                                                                                                                                                                                                                                  
    
    /**
     * This option is used as one of the steps
     * required to allow the use of an "#include"
     * type behaviour. In this case the directive
     * is "#parse". See the TOKEN_MGR_DECLS section
     * below for details on how the TokenManager is
     * modified to allow this behaviour.
     */
    COMMON_TOKEN_ACTION=true;
    
    DEBUG_PARSER=false;
    DEBUG_TOKEN_MANAGER=false;
}    

PARSER_BEGIN(Parser)

package org.apache.velocity.runtime.parser;

import java.io.*;
import java.util.*;

import org.apache.velocity.runtime.Runtime;
import org.apache.velocity.runtime.parser.node.*;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.util.StringUtils;

/**
 * This class is responsible for parsing a Velocity
 * template. This class was generated by JavaCC using
 * the JJTree extension to produce an Abstract
 * Syntax Tree (AST) of the template.
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href="mailto:jvanzyl@periapt.com">Jason van Zyl</a>
 * @author <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
 * @version $Id: Parser.jj,v 1.27 2000/11/08 02:32:18 geirm Exp $ 
*/
public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
    /**
     *  This Hashtable contains a list of all of the dynamic directives.
     */
    private Hashtable directives = new Hashtable(0);
    
    /** This was added to allow the parser to be associated
     * with a particular syntax. JavaCC doesn't generate
     * a constructor without parameters. The normal constructor
     * takes a single argument which an InputStream. But in
     * order to make the parser dynamically loadable this
     * constructor had to be added. This also allows us to
     * create a single instance of a parser and reuse
     * it over and over.
     */
    public Parser()
    {
        this(new ByteArrayInputStream("\n".getBytes()));
    }

    /** This was also added to allow parsers to be dynamically
     * loadable.
     * 
     * Taken from the generated constructor in Parser.java.
     * Just be watchful when you change the grammar because
     * the generated method changes when the grammar changes
     * WRT to adding new token types. So you have to
     * occasionally do some cutting and pasting :-)
     *
     * It would be A LOT better it you could subclass grammars
     * and override particular methods but that's not
     * possible with JavaCC. I believe that you can do
     * this with ANTLR though.
     */
    public SimpleNode parse(InputStream stream) throws ParseException
    {
        SimpleNode sn = null;
        try
        {
            token_source.clearStateVars();
            ReInit(stream);
            n = process();
        }
        catch (Exception e )
        {
            Runtime.error ("Parser Error: " + StringUtils.stackTrace(e));
        }
        return sn;
    }        
    /**
     *  This method sets the directives Hashtable
     */
    public void setDirectives(Hashtable directives)
    {
        this.directives = directives;
    }

    /**
     *  This method gets the directives Hashtable
     */
    public Directive getDirective(String directive)
    {
        return (Directive) directives.get(directive);
    }

    /**
     *  This method finds out of the directive exists in the directives 
     *  Hashtable.
     */
    public boolean isDirective(String directive)
    {
        if (directives.containsKey(directive))
            return true;
        else
            return false;
    }            
}

PARSER_END(Parser)

/**
 * This gets inserted into the ParserMacroTokenManager
 * and is being used here strictly for the #parse
 * directive: an #include type behaviour. We have
 * to save the state the stream currently being
 * parsed and we have to save the state of the
 * lexer (TokenManager class) then we create
 * a new stream from the file named in the
 * #parse directive then we ReInit the lexer. 
 * Whatever it parses will get placed 
 * into the AST.
 *
 * I need a simple way to detect circular
 * inclusions so this thing doesn't go wild
 * and drag down the VM.
 */
TOKEN_MGR_DECLS: 
{  
    private int fileDepth = 0;

    private int lparen = 0;
    private int rparen = 0;

    Stack stateStack = new Stack();
    public boolean bDebugPrint_ = false;

    private boolean inReference;
    public boolean inDirective;
    private boolean inComment;
    private boolean inSet;

    Stack streams = new Stack();
    Stack states = new Stack();
   
    /**
     * Retrieve the oldStream and oldState and
     * continue processing the input.
     */
    void popFile()
    {
        ReInit((ASCII_CharStream) streams.pop(), ((Integer) states.pop()).intValue());
        fileDepth--;
    }    
    
    private boolean AtParent()
    {
        if (fileDepth == 0)
            return true;
        else
            return false;
    }
    
    void CommonTokenAction(Token t)
    {
        if (t.kind == EOF && ! AtParent())
        {
            Token new_t;
            popFile();
            new_t = getNextToken();
            t.kind = new_t.kind;
            t.beginLine = new_t.beginLine;
            t.beginColumn = new_t.beginColumn;
            t.endLine = new_t.endLine;
            t.endColumn = new_t.endColumn;
            t.image = new_t.image;
            t.next = new_t.next;
            t.specialToken = new_t.specialToken;
        }
    } 

    /**
     *  pushes the current state onto the 'state stack',
     *  and maintains the parens counts
     *  public because we need it in PD & VM handling
     *
     *  @return boolean : success.  It can fail if the state machine
     *     gets messed up.
     */
    public boolean stateStackPop()
    {
      
        Hashtable hStack;

        try
        {
            hStack = (Hashtable) stateStack.pop();
        }
        catch( EmptyStackException e)
        {
            lparen=0;
            SwitchTo(DEFAULT);
            return false;
        }

        if( bDebugPrint_ )
            System.out.println(" stack pop (" + stateStack.size() + ") : lparen=" + ( (Integer) hStack.get("lparen")).intValue() 
                + " newstate=" +  ( (Integer)  hStack.get("lexstate")).intValue() );
       
        lparen = ( (Integer) hStack.get("lparen")).intValue();
        rparen = ( (Integer) hStack.get("rparen")).intValue();
        SwitchTo( ( (Integer) hStack.get("lexstate")).intValue() ); 
    
        return true;
    }

    /**
     *  pops a state off the stack, and restores paren counts
     *
     *  @return boolean : success of operation
     */
    public boolean stateStackPush()
    {
        if( bDebugPrint_ )
            System.out.println(" (" + stateStack.size() + ") pushing cur state : " + curLexState );
            
        Hashtable hStack = new Hashtable();
        hStack.put("lexstate", new Integer( curLexState ) );
        hStack.put("lparen", new Integer( lparen ));
        hStack.put("rparen", new Integer( rparen ));
        lparen = 0;

        stateStack.push( hStack );

        return true;
    }

    /**
     *  Clears all state variables, resets to
     *  start values, clears stateStack.  Call
     *  before parsing.
     *  @return void
     */   
    public void clearStateVars()
    {
        stateStack.clear();
        
        lparen = 0;
        rparen = 0;
        inReference = false;
        inDirective = false;
        inComment = false;
        inSet = false;
        
        return;
    }

    /**
     *  Produces a processed output for an escaped control directive
     */
    private String escapedDirective( String strImage, String strDirective )
    {
        int iLast = strImage.lastIndexOf("\\");
        return ( strImage.substring(0,iLast/2) + strDirective); 
    }

    /**
     *  handles the dropdown logic when encountering a RPAREN
     */
    private void RPARENHandler()
    {
        /*
         *  Ultimately, we want to drop down to the state below the one that has an open (
         *  if we hit bottom (DEFAULT), that's fine. It's just text schmoo.
         *
         */
   
        boolean bClosed = false;

        if (inComment)
            bClosed = true;

        while( !bClosed) 
        {
            /*
             * look at current state.  If we haven't seen a lparen in this state
             * then we drop a state, because this lparen clearly closes our state
             */

            if( lparen > 0)
            {
                /*
                 *  if rparen + 1 == lparen, then this state is closed. Otherwise, increment
                 *  and keep parsing
                 */

                 if( lparen == rparen + 1)
                 {
                       stateStackPop();
                 }  
                else
                {   
                    rparen++;
                }
                      
                 bClosed = true;
            }
            else
            {
                /*
                 * now, drop a state
                 */
        
                if(!stateStackPop())
                    break;
            } 
        }
    }
} 

/* ------------------------------------------------------------------------
 *
 * Tokens
 *
 *  Note : we now have another state, REFMODIFIER.  This is sort of a 
 *  type of REFERENCE state, simply use to use the DIRECTIVE token
 *  set when we are processing a $foo.bar() construct
 *
 * ------------------------------------------------------------------------- */

<DIRECTIVE,REFMODIFIER,REFMOD2>
TOKEN:
{ 
    <LBRACKET: "[">
|   <RBRACKET: "]">
}

<DIRECTIVE,REFMOD2>
TOKEN:
{
    <COMMA:",">
}

<DIRECTIVE,REFMODIFIER>
TOKEN:
{
    <LPAREN: "(">
    {
        if (!inComment)
            lparen++;

        /*
         *  if in REFERENCE and we have seen the dot, then move to REFMOD2 -> Modifier()
         */

        if (curLexState == REFMODIFIER )
            SwitchTo( REFMOD2 ); 
    }
}

/* 
 *  we never will see a ')' in anything but DIRECTIVE and REFMOD2.  Each have their own
 */
<DIRECTIVE>
TOKEN:
{
    /*
     *  We will eat any whitespace upto and including a newline for directives
     */
    <RPAREN: ")" ( ( " " | "\t" )* ( "\n" | "\r" | "\r\n" ))?>
    {
       RPARENHandler();
    }    
}


<REFMOD2>
TOKEN:
{
    /*
     *  in REFMOD2, we don't want to bind the whitespace and \n like we do when closing a directive.
     */
    <REFMOD2_RPAREN: ")">
    {
        /*
         *  need to simply switch back to REFERENCE, not drop down the stack
         *  because we can (infinitely) chain, ala $foo.bar().blargh().woogie().doogie()
         */

        SwitchTo( REFERENCE );
    }    
}

/*----------------------------------------------
 *
 *  escape "\\" handling for the built-in directives
 *
 *--------------------------------------------- */
TOKEN:
{
    /*
     *  We have to do this, because we want these to be a Text node, and
     *  whatever follows to be peer to this text in the tree.
     *  
     *  We need to touch the ASTs for these, because we want an even # of \'s
     *  to render properly in front of the block
     *
     *  This is really simplistic.  I actually would prefer to find them in
     *  grammatical context, but I am neither smart nor rested, a receipe
     *  for disaster, another long night with Mr. Parser, or both.
     */

     <ESCAPE_SET_DIRECTIVE : ("\\\\")* "\\#set">   
     { 
        matchedToken.image = escapedDirective( matchedToken.image, "#set");
     }

|    <ESCAPE_IF_DIRECTIVE : ("\\\\")*  "\\#if">   
     { 
         matchedToken.image = escapedDirective( matchedToken.image, "#if");
     }

|    <ESCAPE_END_DIRECTIVE : ("\\\\")* "\\#end">   
     { 
        matchedToken.image = escapedDirective( matchedToken.image, "#end");
     }     

|    <ESCAPE_ELSEIF_DIRECTIVE: ("\\\\")* "\\#elseif">
     { 
        matchedToken.image = escapedDirective( matchedToken.image, "#elseif");
     }

|    <ESCAPE_ELSE_DIRECTIVE: ("\\\\")* "\\#else"> 
     { 
        matchedToken.image = escapedDirective( matchedToken.image, "#else");
     }

|    <ESCAPE_STOP_DIRECTIVE: ("\\\\")* "\\#stop">
     { 
        matchedToken.image = escapedDirective( matchedToken.image, "#stop");
     }

}


/*
 *  needed because #set is so wacky in it's desired behavior.  We want set to eat any preceeding whitespace
 *  so it is invisible in formatting. (As it should be.)  If this works well, I am going to chuck the whole MORE:
 *  token abomination. 
 */
TOKEN:
{
  <SET_DIRECTIVE: (" "|"\t")* ("\\\\")*  "#set" >
    { 
        if (! inComment)
        {
            inDirective = true;

            if ( bDebugPrint_ )
                System.out.print("#set :  going to " + DIRECTIVE );
            
            stateStackPush();
            inSet = true; 
            SwitchTo(DIRECTIVE);
        }
   }
}

<*>
MORE :
{
    /*
     *   Note : DOLLARBANG is a duplicate of DOLLAR.  They must be identical.
     */

    <DOLLAR: ("\\")* "$"> 
    { 
        if (! inComment)
        {
            inReference = true;

           if ( bDebugPrint_ )
                System.out.print( "$  : going to " + REFERENCE );

            stateStackPush();
            SwitchTo(REFERENCE);
        }            
    }

|   <DOLLARBANG: "$!"> 
    { 
        if (! inComment)
        {
            inReference = true;

           if ( bDebugPrint_ )
                System.out.print( "$!  : going to " + REFERENCE );

            stateStackPush();
            SwitchTo(REFERENCE);
        }            
    }

|   "##"
   { 
        inComment = true;
        stateStackPush();
        SwitchTo(IN_SINGLE_LINE_COMMENT);
     }

|   <"#**" ~["#"]> 
    { 
        input_stream.backup(1); 
        inComment = true; 
        stateStackPush();
        SwitchTo( IN_FORMAL_COMMENT);
    } 
    
|   "#*" 
    { 
        inComment=true;
        stateStackPush();
        SwitchTo( IN_MULTI_LINE_COMMENT ); 
    } 

|   <HASH : ("\\")* "#" > 
    { 
        if (! inComment)
        {
            inDirective = true;

            if ( bDebugPrint_ )
                System.out.print("# :  going to " + DIRECTIVE );
            
            stateStackPush();
            SwitchTo(PRE_DIRECTIVE);
        }
    } 
}   

TOKEN :
{
    <ESCAPE: "\\">
|   <TEXT: (~["$", "#", "\\"])+ >
}    

/* -----------------------------------------------------------------------
 * 
 *   *_COMMENT Lexical tokens
 *
 *-----------------------------------------------------------------------*/
<IN_SINGLE_LINE_COMMENT>
TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > 
  { 
     inComment = false;
     stateStackPop();
  } 

}

<IN_FORMAL_COMMENT>
TOKEN :
{
  <FORMAL_COMMENT: "*#" > 
  {     
    inComment = false;
    stateStackPop();
  } 
}

<IN_MULTI_LINE_COMMENT>
TOKEN :
{
  <MULTI_LINE_COMMENT: "*#" > 
  { 
    inComment = false; 
    stateStackPop();
  } 
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* -----------------------------------------------------------------------
 * 
 *  DIRECTIVE Lexical State (some of it, anyway)
 * 
 * ---------------------------------------------------------------------- */
<DIRECTIVE,REFMOD2> 
SKIP:
{
    " "
|   "\t"
//|   "\n"
//|   "\r"
}


<REFERENCE,DIRECTIVE,REFMODIFIER,REFMOD2>
TOKEN :
{
   <STRING_LITERAL: ( "\"" ( ~["\"","\n","\r"] )* "\"" ) >
    {
        /*
         *  - if we are in REFERENCE || REFMODIFIER then " is an ender
         *  - if we are in DIRECTIVE and haven't seen ( yet, then also drop out. 
         *      don't forget to account for the beloved yet wierd #set
         *  - finally, if we are in REFMOD2 (remember : $foo.bar( ) then " is ok!
         */

        if (curLexState == REFERENCE || curLexState == REFMODIFIER)
            stateStackPop();
        else if( curLexState == DIRECTIVE && !inSet && lparen == 0)
            stateStackPop();    
    }

|   <TRUE: "true">
|   <FALSE: "false">
}

<DIRECTIVE>
TOKEN :
{
    <NEWLINE: "\n" | "\r" | "\r\n" >
    {
        if ( bDebugPrint_ )
            System.out.println(" NEWLINE :");

        stateStackPop();      
        
        if (inSet)
            inSet = false;
        
        if (inDirective)
            inDirective = false;
    }        
}    


<DIRECTIVE>
TOKEN : 
{
    <MINUS: "-">
|   <PLUS: "+">
|   <MULTIPLY: "*">
|   <DIVIDE: "/">
|   <MODULUS: "%">
|   <LOGICAL_AND: "&&">
|   <LOGICAL_OR: "||">
|   <LOGICAL_LT: "<">
|   <LOGICAL_LE: "<=">
|   <LOGICAL_GT: ">">
|   <LOGICAL_GE: ">=">
|   <LOGICAL_EQUALS: "==">
|   <LOGICAL_NOT_EQUALS: "!=">
|   <LOGICAL_NOT: "!">
|   <EQUALS: "=" >
}

<PRE_DIRECTIVE> 
TOKEN :
{
    <END: "end" ( ( " " | "\t" )* ( "\n" | "\r" | "\r\n" ) )? > 
    { 
        inDirective = false; 
        stateStackPop();
    } 

|   <IF_DIRECTIVE: "if">
    {
        SwitchTo(DIRECTIVE);
    }

|   <ELSEIF_DIRECTIVE: "elseif">
    {
        SwitchTo(DIRECTIVE);
    }

|   <ELSE_DIRECTIVE: "else"> 
     { 
        inDirective = false; 
        stateStackPop();
    } 

|   <STOP_DIRECTIVE: "stop">
    {
        matchedToken.kind = EOF;
        fileDepth = 0;
    }
}

<PRE_DIRECTIVE,DIRECTIVE,REFMOD2>
TOKEN:
{
   <#DIGIT: [ "0"-"9" ] >
|   <NUMBER_LITERAL: (<DIGIT>)+ >
    {
        /*
         * check to see if we are in set
         *    ex.  #set $foo = $foo + 3
         *  because we want to handle the \n after
         */

        if ( lparen == 0 && !inSet && curLexState != REFMOD2)
            stateStackPop();
    }
}

<PRE_DIRECTIVE,DIRECTIVE>
TOKEN:
{
    <#LETTER: [ "a"-"z", "A" - "Z" ] >
|   <WORD: (<LETTER>)+ >
}

/* -----------------------------------------------------------------------
 * 
 *  REFERENCE Lexical States
 *
 *  This is more than a single state, because of the  structure of
 *  the VTL references.  We use three states because the set of tokens
 *  for each state can be different.
 *
 *  $foo.bar( "arg" )
 *  ^   ^   ^
 *  |   |   |
 *  ----------- >  REFERENCE : state initiated by the '$' character.  Continues 
 *      |   |       until end of the reference, or the . character.
 *      |------ >  REFMODIFIER : state switched to when the <DOT> is encountered.
 *          |       note that this is a switch, not a push. See notes at bottom
 *          |       re stateStack.
 *          |-- >  REFMOD2 : state switch to when the LPAREN is encountered.
 *                  again, this is a switch, not a push.
 *
 * ---------------------------------------------------------------------------- */

<REFERENCE,REFMODIFIER,REFMOD2> 
TOKEN :
{
    <#ALPHA_CHAR: ["a"-"z", "A"-"Z"] >
|   <#ALPHANUM_CHAR: [ "a"-"z", "A"-"Z", "0"-"9" ] >
|   <#IDENTIFIER_CHAR: [ "a"-"z", "A"-"Z", "0"-"9", "-", "_" ] >
|   <IDENTIFIER:  <ALPHA_CHAR> (<IDENTIFIER_CHAR>)* >
|   <DOT: "." <ALPHA_CHAR>> 
    { 
        /*
         * push the alpha char back into the stream so the following identifier is complete
         */

        input_stream.backup(1); 

        /*
         *  and munge the <DOT> so we just get a . when we have normal text that looks like a ref.ident
         */

        matchedToken.image = ".";

        if ( bDebugPrint_ ) 
            System.out.print("DOT : switching to " + REFMODIFIER); 
        SwitchTo(REFMODIFIER); 

    }
|   <LCURLY: "{">
|   <RCURLY: "}">
    {
        stateStackPop();
    }
}

<REFERENCE,REFMODIFIER,REFMOD2> 
SPECIAL_TOKEN :
{
    <REFERENCE_TERMINATOR: ~[] >
    {   
        /*
         * push every terminator character back into the stream  
         */

        input_stream.backup(1);
      
        inReference = false;
    
        if ( bDebugPrint_ )
            System.out.print("REF_TERM :");
        
        stateStackPop();
    }
}

<PRE_DIRECTIVE> 
SPECIAL_TOKEN :
{
    <DIRECTIVE_TERMINATOR: ~[] >
    {
        if ( bDebugPrint_ )
            System.out.print("DIRECTIVE_TERM :");
 
        input_stream.backup(1); 
        inDirective = false;
        stateStackPop();       
    }
}

/**
 * This method is what starts the whole parsing
 * process. After the parsing is complete and
 * the template has been turned into an AST,
 * this method returns the root of AST which
 * can subsequently be traversed by a visitor
 * which implements the ParserVisitor interface
 * which is generated automatically by JavaCC
 */
SimpleNode process() : {/*@bgen(jjtree) process */
  ASTprocess jjtn000 = new ASTprocess(this, JJTPROCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) process */
   try {
/*@egen*/
   ( Statement() )* <EOF>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return jjtn000; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/**
 * These are the types of statements that
 * are acceptable in Velocity templates.
 */
void Statement()       : {}
{
    IfStatement()
|   StopStatement()
|   Reference()
|   Comment()
|   SetDirective()
|   Directive()
|   Text()
}

void Comment() : {/*@bgen(jjtree) Comment */
  ASTComment jjtn000 = new ASTComment(this, JJTCOMMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Comment */
    try {
/*@egen*/
    <SINGLE_LINE_COMMENT>
|   <MULTI_LINE_COMMENT>
|   <FORMAL_COMMENT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumberLiteral() : {/*@bgen(jjtree) NumberLiteral */
  ASTNumberLiteral jjtn000 = new ASTNumberLiteral(this, JJTNUMBERLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NumberLiteral */
    try {
/*@egen*/
    <NUMBER_LITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

void StringLiteral() : {/*@bgen(jjtree) StringLiteral */
  ASTStringLiteral jjtn000 = new ASTStringLiteral(this, JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StringLiteral */
    try {
/*@egen*/
    <STRING_LITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

/**
 * This method corresponds to variable
 * references in Velocity templates.
 * The following are examples of variable
 * references that may be found in a
 * template:
 *
 * $foo
 * $bar
 *
 */
void Identifier() : {/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/    
    <IDENTIFIER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Word() : {/*@bgen(jjtree) Word */
  ASTWord jjtn000 = new ASTWord(this, JJTWORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Word */
    try {
/*@egen*/
    <WORD>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

/**
 *   Supports the arguments for the Pluggable Directives
 *   @see Directive()
 */
void DirectiveArg()       : {}
{
    Reference()
|   Word()  
|   StringLiteral()
|   NumberLiteral()
|   ObjectArray()
}

/**
 *   Supports the Pluggable Directives
 *     #foo( arg+ )
 */
SimpleNode Directive() : 
{/*@bgen(jjtree) Directive */
    ASTDirective jjtn000 = new ASTDirective(this, JJTDIRECTIVE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
    Directive d;
}
{/*@bgen(jjtree) Directive */
    try {
/*@egen*/
    /*
     *  There are two things we do here :
     *  1) If the first char is a \, then this has been escaped, so don't 
     *     continue.  We will take care of the rest in ASTDirective.java
     *  2) Get the directive identifier and check to see if this is a directive.
     *     Note that because '#' is a <MORE> token, the identifier is preceeded by the '#'
     */

    t = <WORD>
    {
        /*
         *  We need to count the preceeding \'s.  If t starts with an odd number of \'s...
         */

         int i = 0;
         int iLen = t.image.length();

         while( i < iLen && t.image.charAt(i) == '\\' )
            i++;         
                
        if( t.image.startsWith("\\") && (i % 2) != 0 )
        {
            token_source.stateStackPop();
            token_source.inDirective = false;
            return jjtn000;            
        }
        else
        {
            d = (Directive) directives.get(t.image.substring(i+1));
        
            if (d == null)
            {
                token_source.stateStackPop();
                token_source.inDirective = false;
                return jjtn000;
            }
        }            

        token_source.SwitchTo( DIRECTIVE );
    }

    /*
     *  if this is indeed a token, match the #foo ( arg ) pattern
     */

    <LPAREN> (DirectiveArg())+ <RPAREN>
    {
        if (d.getType() == Directive.LINE)
            return jjtn000;
    }/*@bgen(jjtree) Block */
    {
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/

    /*
     *  and the following block if the PD needs it
     */
    
    ( Statement() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ 
    EndStatement()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}    

void ObjectArray() : {/*@bgen(jjtree) ObjectArray */
  ASTObjectArray jjtn000 = new ASTObjectArray(this, JJTOBJECTARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectArray */
    try {
/*@egen*/
    <LBRACKET> [ Parameter() ( <COMMA> Parameter() )* ] <RBRACKET>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * This method has yet to be fully implemented
 * but will allow arbitrarily nested method
 * calls
 */
void Parameter()      : {}
{
    StringLiteral()
|   ObjectArray()
|   True()
|   False()
|   Reference()
|   NumberLiteral()
}

/**
 * This method has yet to be fully implemented
 * but will allow arbitrarily nested method
 * calls
 */
void Method() : {/*@bgen(jjtree) Method */
  ASTMethod jjtn000 = new ASTMethod(this, JJTMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Method */
    try {
/*@egen*/
    Identifier() <LPAREN> [ Parameter() ( <COMMA> Parameter() )* ] <REFMOD2_RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Reference() : {/*@bgen(jjtree) Reference */
  ASTReference jjtn000 = new ASTReference(this, JJTREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Reference */
    try {
/*@egen*/ 
    // This should be changed to Indentifier() now. Make
    // it easier to walk the AST.
    [<LCURLY>]
    <IDENTIFIER>
    [<RCURLY>]
    (LOOKAHEAD(2) <DOT> (LOOKAHEAD(3) Method() | Identifier() ) [<RCURLY>] )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void True() : {/*@bgen(jjtree) True */
  ASTTrue jjtn000 = new ASTTrue(this, JJTTRUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) True */
    try {
/*@egen*/
    <TRUE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void False() : {/*@bgen(jjtree) False */
  ASTFalse jjtn000 = new ASTFalse(this, JJTFALSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) False */
    try {
/*@egen*/
    <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * This method is responsible for allowing
 * all non-grammar text to pass through
 * unscathed.
 */
void Text() : 
{/*@bgen(jjtree) Text */
    ASTText jjtn000 = new ASTText(this, JJTTEXT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Text */
    try {
/*@egen*/
    <TEXT>
|   <NEWLINE>  
|   <DOT>
|   <RPAREN>
|   <LPAREN>
|   <NUMBER_LITERAL>
|   <STRING_LITERAL>
|   <ESCAPE>
|   <ESCAPE_SET_DIRECTIVE>
|   <ESCAPE_IF_DIRECTIVE>
|   <ESCAPE_END_DIRECTIVE>   
|   <ESCAPE_ELSEIF_DIRECTIVE>
|   <ESCAPE_ELSE_DIRECTIVE> 
|   <ESCAPE_STOP_DIRECTIVE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* -----------------------------------------------------------------------
 * 
 *  Defined Directive Syntax
 * 
 * ----------------------------------------------------------------------*/

void IfStatement() : {/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
    try {
/*@egen*/
    <IF_DIRECTIVE> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree) Block */
    {
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( Statement() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/
    [ LOOKAHEAD(1) ( ElseIfStatement() )+ ]
    [ LOOKAHEAD(1) ElseStatement() ]
    EndStatement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void EndStatement() : {/*@bgen(jjtree) EndStatement */
  ASTEndStatement jjtn000 = new ASTEndStatement(this, JJTENDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EndStatement */
    try {
/*@egen*/
    <END>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ElseStatement() : {/*@bgen(jjtree) ElseStatement */
  ASTElseStatement jjtn000 = new ASTElseStatement(this, JJTELSESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ElseStatement */
    try {
/*@egen*/
    <ELSE_DIRECTIVE>/*@bgen(jjtree) Block */
    {
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/ 
    ( Statement() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*//*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ElseIfStatement() : {/*@bgen(jjtree) ElseIfStatement */
  ASTElseIfStatement jjtn000 = new ASTElseIfStatement(this, JJTELSEIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ElseIfStatement */
    try {
/*@egen*/
    <ELSEIF_DIRECTIVE> 
    <LPAREN> Expression() <RPAREN>/*@bgen(jjtree) Block */
    {
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( Statement() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*//*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SetDirective() : {/*@bgen(jjtree) SetDirective */
  ASTSetDirective jjtn000 = new ASTSetDirective(this, JJTSETDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SetDirective */
   try {
/*@egen*/
   (<SET_DIRECTIVE> Expression() [<NEWLINE>] )/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}    


/**
 * This method corresponds to the #stop
 * directive which just simulates and EOF
 * so that parsing stops. The #stop directive
 * is useful for end-user debugging
 * purposes.
 */
void StopStatement()      : {}
{    
    <STOP_DIRECTIVE>
}

/* -----------------------------------------------------------------------
 * 
 *  Expression Syntax
 * 
 * ----------------------------------------------------------------------*/

void Expression() : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    LOOKAHEAD( PrimaryExpression() <EQUALS> ) Assignment()
|   ConditionalOrExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Assignment()                : {/*@bgen(jjtree) #Assignment( 2) */
  ASTAssignment jjtn000 = new ASTAssignment(this, JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Assignment( 2) */
    try {
/*@egen*/
    PrimaryExpression() <EQUALS> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  2);
      }
    }
/*@egen*/
}

void ConditionalOrExpression()       : {}
{
  ConditionalAndExpression()
  ( <LOGICAL_OR>/*@bgen(jjtree) #OrNode( 2) */
                 {
                   ASTOrNode jjtn001 = new ASTOrNode(this, JJTORNODE);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                 }
                 try {
/*@egen*/ ConditionalAndExpression()/*@bgen(jjtree)*/
                 } catch (Throwable jjte001) {
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte001 instanceof ParseException) {
                     throw (ParseException)jjte001;
                   }
                   if (jjte001 instanceof RuntimeException) {
                     throw (RuntimeException)jjte001;
                   }
                   throw (Error)jjte001;
                 } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  2);
                   }
                 }
/*@egen*/ )*
}


void ConditionalAndExpression()       : {}
{
  EqualityExpression()
  ( <LOGICAL_AND>/*@bgen(jjtree) #AndNode( 2) */
                   {
                     ASTAndNode jjtn001 = new ASTAndNode(this, JJTANDNODE);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                   }
                   try {
/*@egen*/  EqualityExpression()/*@bgen(jjtree)*/
                   } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof ParseException) {
                       throw (ParseException)jjte001;
                     }
                     if (jjte001 instanceof RuntimeException) {
                       throw (RuntimeException)jjte001;
                     }
                     throw (Error)jjte001;
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  2);
                     }
                   }
/*@egen*/ )*
}

void EqualityExpression()       : {}
{
    RelationalExpression()
    (
          <LOGICAL_EQUALS>/*@bgen(jjtree) #EQNode( 2) */
                           {
                             ASTEQNode jjtn001 = new ASTEQNode(this, JJTEQNODE);
                             boolean jjtc001 = true;
                             jjtree.openNodeScope(jjtn001);
                           }
                           try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
                           } catch (Throwable jjte001) {
                             if (jjtc001) {
                               jjtree.clearNodeScope(jjtn001);
                               jjtc001 = false;
                             } else {
                               jjtree.popNode();
                             }
                             if (jjte001 instanceof ParseException) {
                               throw (ParseException)jjte001;
                             }
                             if (jjte001 instanceof RuntimeException) {
                               throw (RuntimeException)jjte001;
                             }
                             throw (Error)jjte001;
                           } finally {
                             if (jjtc001) {
                               jjtree.closeNodeScope(jjtn001,  2);
                             }
                           }
/*@egen*/
        | <LOGICAL_NOT_EQUALS>/*@bgen(jjtree) #NENode( 2) */
                               {
                                 ASTNENode jjtn002 = new ASTNENode(this, JJTNENODE);
                                 boolean jjtc002 = true;
                                 jjtree.openNodeScope(jjtn002);
                               }
                               try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
                               } catch (Throwable jjte002) {
                                 if (jjtc002) {
                                   jjtree.clearNodeScope(jjtn002);
                                   jjtc002 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte002 instanceof ParseException) {
                                   throw (ParseException)jjte002;
                                 }
                                 if (jjte002 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte002;
                                 }
                                 throw (Error)jjte002;
                               } finally {
                                 if (jjtc002) {
                                   jjtree.closeNodeScope(jjtn002,  2);
                                 }
                               }
/*@egen*/
    )*
}

void RelationalExpression()       : {}
{
    AdditiveExpression()
    (
          <LOGICAL_LT>/*@bgen(jjtree) #LTNode( 2) */
                       {
                         ASTLTNode jjtn001 = new ASTLTNode(this, JJTLTNODE);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
                       }
                       try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte001) {
                         if (jjtc001) {
                           jjtree.clearNodeScope(jjtn001);
                           jjtc001 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte001 instanceof ParseException) {
                           throw (ParseException)jjte001;
                         }
                         if (jjte001 instanceof RuntimeException) {
                           throw (RuntimeException)jjte001;
                         }
                         throw (Error)jjte001;
                       } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  2);
                         }
                       }
/*@egen*/
        | <LOGICAL_GT>/*@bgen(jjtree) #GTNode( 2) */
                       {
                         ASTGTNode jjtn002 = new ASTGTNode(this, JJTGTNODE);
                         boolean jjtc002 = true;
                         jjtree.openNodeScope(jjtn002);
                       }
                       try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte002) {
                         if (jjtc002) {
                           jjtree.clearNodeScope(jjtn002);
                           jjtc002 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte002 instanceof ParseException) {
                           throw (ParseException)jjte002;
                         }
                         if (jjte002 instanceof RuntimeException) {
                           throw (RuntimeException)jjte002;
                         }
                         throw (Error)jjte002;
                       } finally {
                         if (jjtc002) {
                           jjtree.closeNodeScope(jjtn002,  2);
                         }
                       }
/*@egen*/
        | <LOGICAL_LE>/*@bgen(jjtree) #LENode( 2) */
                       {
                         ASTLENode jjtn003 = new ASTLENode(this, JJTLENODE);
                         boolean jjtc003 = true;
                         jjtree.openNodeScope(jjtn003);
                       }
                       try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte003) {
                         if (jjtc003) {
                           jjtree.clearNodeScope(jjtn003);
                           jjtc003 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte003 instanceof ParseException) {
                           throw (ParseException)jjte003;
                         }
                         if (jjte003 instanceof RuntimeException) {
                           throw (RuntimeException)jjte003;
                         }
                         throw (Error)jjte003;
                       } finally {
                         if (jjtc003) {
                           jjtree.closeNodeScope(jjtn003,  2);
                         }
                       }
/*@egen*/
        | <LOGICAL_GE>/*@bgen(jjtree) #GENode( 2) */
                       {
                         ASTGENode jjtn004 = new ASTGENode(this, JJTGENODE);
                         boolean jjtc004 = true;
                         jjtree.openNodeScope(jjtn004);
                       }
                       try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte004) {
                         if (jjtc004) {
                           jjtree.clearNodeScope(jjtn004);
                           jjtc004 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte004 instanceof ParseException) {
                           throw (ParseException)jjte004;
                         }
                         if (jjte004 instanceof RuntimeException) {
                           throw (RuntimeException)jjte004;
                         }
                         throw (Error)jjte004;
                       } finally {
                         if (jjtc004) {
                           jjtree.closeNodeScope(jjtn004,  2);
                         }
                       }
/*@egen*/
    )*
}

void AdditiveExpression()       : {}
{
    MultiplicativeExpression()
    (
          <PLUS>/*@bgen(jjtree) #AddNode( 2) */
                  {
                    ASTAddNode jjtn001 = new ASTAddNode(this, JJTADDNODE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*/  MultiplicativeExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof ParseException) {
                      throw (ParseException)jjte001;
                    }
                    if (jjte001 instanceof RuntimeException) {
                      throw (RuntimeException)jjte001;
                    }
                    throw (Error)jjte001;
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  2);
                    }
                  }
/*@egen*/
        | <MINUS>/*@bgen(jjtree) #SubtractNode( 2) */
                  {
                    ASTSubtractNode jjtn002 = new ASTSubtractNode(this, JJTSUBTRACTNODE);
                    boolean jjtc002 = true;
                    jjtree.openNodeScope(jjtn002);
                  }
                  try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte002) {
                    if (jjtc002) {
                      jjtree.clearNodeScope(jjtn002);
                      jjtc002 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte002 instanceof ParseException) {
                      throw (ParseException)jjte002;
                    }
                    if (jjte002 instanceof RuntimeException) {
                      throw (RuntimeException)jjte002;
                    }
                    throw (Error)jjte002;
                  } finally {
                    if (jjtc002) {
                      jjtree.closeNodeScope(jjtn002,  2);
                    }
                  }
/*@egen*/
    )*
}

void MultiplicativeExpression()       : {}
{
    UnaryExpression()
    (
          <MULTIPLY>/*@bgen(jjtree) #MulNode( 2) */
                     {
                       ASTMulNode jjtn001 = new ASTMulNode(this, JJTMULNODE);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                     }
                     try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
                     } catch (Throwable jjte001) {
                       if (jjtc001) {
                         jjtree.clearNodeScope(jjtn001);
                         jjtc001 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte001 instanceof ParseException) {
                         throw (ParseException)jjte001;
                       }
                       if (jjte001 instanceof RuntimeException) {
                         throw (RuntimeException)jjte001;
                       }
                       throw (Error)jjte001;
                     } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  2);
                       }
                     }
/*@egen*/
        | <DIVIDE>/*@bgen(jjtree) #DivNode( 2) */
                     {
                       ASTDivNode jjtn002 = new ASTDivNode(this, JJTDIVNODE);
                       boolean jjtc002 = true;
                       jjtree.openNodeScope(jjtn002);
                     }
                     try {
/*@egen*/   UnaryExpression()/*@bgen(jjtree)*/
                     } catch (Throwable jjte002) {
                       if (jjtc002) {
                         jjtree.clearNodeScope(jjtn002);
                         jjtc002 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte002 instanceof ParseException) {
                         throw (ParseException)jjte002;
                       }
                       if (jjte002 instanceof RuntimeException) {
                         throw (RuntimeException)jjte002;
                       }
                       throw (Error)jjte002;
                     } finally {
                       if (jjtc002) {
                         jjtree.closeNodeScope(jjtn002,  2);
                       }
                     }
/*@egen*/
        | <MODULUS>/*@bgen(jjtree) #ModNode( 2) */
                     {
                       ASTModNode jjtn003 = new ASTModNode(this, JJTMODNODE);
                       boolean jjtc003 = true;
                       jjtree.openNodeScope(jjtn003);
                     }
                     try {
/*@egen*/  UnaryExpression()/*@bgen(jjtree)*/
                     } catch (Throwable jjte003) {
                       if (jjtc003) {
                         jjtree.clearNodeScope(jjtn003);
                         jjtc003 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte003 instanceof ParseException) {
                         throw (ParseException)jjte003;
                       }
                       if (jjte003 instanceof RuntimeException) {
                         throw (RuntimeException)jjte003;
                       }
                       throw (Error)jjte003;
                     } finally {
                       if (jjtc003) {
                         jjtree.closeNodeScope(jjtn003,  2);
                       }
                     }
/*@egen*/
    )*
}

void UnaryExpression()       : {}
{
    <LOGICAL_NOT>/*@bgen(jjtree) #NotNode( 1) */
                  {
                    ASTNotNode jjtn001 = new ASTNotNode(this, JJTNOTNODE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof ParseException) {
                      throw (ParseException)jjte001;
                    }
                    if (jjte001 instanceof RuntimeException) {
                      throw (RuntimeException)jjte001;
                    }
                    throw (Error)jjte001;
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  1);
                    }
                  }
/*@egen*/
|   PrimaryExpression()
}

void PrimaryExpression()       : {}
{    
    StringLiteral()
|   NumberLiteral()    
|   Reference()
|   ObjectArray()
|   True()
|   False()
|   <LPAREN> Expression() <RPAREN>
}


/* ======================================================================
 
   Notes
   -----
 
    template == the input stream for this parser, contains 'VTL' mixed in with 'schmoo'
    VTL == Velocity Template Language : the references, directives, etc
    shmoo == the non-VTL component of a template
    reference == VTL entity that represents data within the context. ex. $foo
    directive == VTL entity that denotes 'action' (#set, #foreach, #if )
    defined directive (DD) == VTL directive entity that is expressed explicitly w/in this grammar
    pluggable directive (PD) == VTL directive entity that is defined outside of the grammar.  PD's
            allow VTL to be easily expandable w/o parser modification.
 
    The problem with parsing VTL is that an input stream consists generally of little
    bits of VTL mixed in with 'other stuff, referred to as 'schmoo'.  Unlike
    other languages, like C or Java, where the parser can punt whenever it encounters 
    input that doesn't conform to the grammar, the VTL parser can't do that.  It must simply 
    output the schmoo and keep going.  
 
    There are a few things that we do here :
     - define a set of parser states (DEFAULT, DIRECTIVE, REFERENCE, etc)
     - define for each parser state a set of tokens for each state
     - define the VTL grammar, expressed (mostly) in the productions such as Text(), SetStatement(), etc.
   
    It is clear that this expression of the VTL grammer (the contents of this .jjt file) is maturing and
    evolving as we learn more about how to parse VTL ( and as I learn about parsing...), so in the event 
    this documentation is in disagreement w/ the source, the source takes precedence. :)
 
    Parser States
    -------------
    DEFAULT :  This is the base or starting state, and strangely enough, the default state.
 
    PRE_DIRECTIVE : State immediately following '#' before we figure out which defined or pluggable
        directive (or neither) we are working with.
     
    DIRECTIVE : This state is triggered by the a match of a DD or a PD.

    REFERENCE : Triggered by '$'. Analagous to PRE_DIRECTIVE.

    REFMODIFIER : Triggered by .<alpha> when in REFERENCE.

    REFMOD2 : Triggered by ( when in REFMODIFIER
 
    (cont)

    Escape Sequences
    ----------------
    The escape processing in VTL is very simple.  The '\' character acts only as an escape when :
    
        1) On or more touch a VTL element.

    A VTL element is either :

        1) It preceeds a reference that is in the context.

        2) It preceeds a defined directive (#set, #if, #end, etc) or a valid pluggable directive, 
            such as #foreach

    In all other cases the '\' is just another piece of text.  The purpose of this is to allow the non-VTL
    parts of a template (the 'schmoo') to not have to be altered for processing by Velocity.

    So if in the context $foo and $bar were defined and $woogie was not 
        
        \$foo  \$bar \$woogie

    would output

        $foo  $bar  \$woogie

    Further, you can stack them and they affect left to right, just like convention escape characters in other languages.

        \$foo = $foo
        \\$foo = \<foo>
        \\\$foo = \$foo

    
    What You Expect
    ---------------
    The recent versions of the parser are trying to support precise output to support general template use.
    The directives do not render trailing whitespace and newlines if followed by a newline.  They will render preceeding whitespace.
    The only exception is #set, which also eats preceeding whitespace.
 
    So, with a template :

        ------
        #set $foo="foo"
        #if($foo)
        \$foo = $foo
        #end
        ------

    it will render precisely :

        ------
        $foo = foo
        ------

*/
 
