/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names "The Jakarta Project", "Tomcat", and "Apache Software
 *    Foundation" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

options
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
    
    /**
     * The parser must be non-static in order for the
     * above option to work, otherwise the parser value
     * is passed in as null, which isn't all the useful ;)
     */
    STATIC=false;                                                                                                                                                                                                                                                                                                                  
    
    /**
     * This option is used as one of the steps
     * required to allow the use of an "#include"
     * type behaviour. In this case the directive
     * is "#parse". See the TOKEN_MGR_DECLS section
     * below for details on how the TokenManager is
     * modified to allow this behaviour.
     */
    COMMON_TOKEN_ACTION=true;
    
    DEBUG_PARSER=false;
    DEBUG_TOKEN_MANAGER=false;
}    

PARSER_BEGIN(Parser)

package org.apache.velocity.runtime.parser;

import java.io.*;
import java.util.*;

import org.apache.velocity.runtime.parser.node.*;
import org.apache.velocity.runtime.directive.Directive;

/**
 * This class is responsible for parsing a Velocity
 * template. This class was generated by JavaCC using
 * the JJTree extension to produce an Abstract
 * Syntax Tree (AST) of the template.
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href="mailto:jvanzyl@periapt.com">Jason van Zyl</a>
 * @author <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
 * @version $Id: Parser.jj,v 1.8 2000/10/27 05:18:44 jvanzyl Exp $ 
*/
public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
    
    
    Hashtable directives;
    
    /* This was added to allow the parser to be associated
     * with a particular syntax. JavaCC doesn't generate
     * a constructor without parameters. The normal constructor
     * takes a single argument which an InputStream. But in
     * order to make the parser dynamically loadable this
     * constructor had to be added. This also allows us to
     * create a single instance of a parser and reuse
     * it over and over.
     */
    public Parser()
    {
        this(new ByteArrayInputStream("\n".getBytes()));
    }

    /* This was also added to allow parsers to be dynamically
     * loadable.
     * 
     * Taken from the generated constructor in Parser.java.
     * Just be watchful when you change the grammar because
     * the generated method changes when the grammar changes
     * WRT to adding new token types. So you have to
     * occasionally do some cutting and pasting :-)
     *
     * It would be A LOT better it you could subclass grammars
     * and override particular methods but that's not
     * possible with JavaCC. I believe that you can do
     * this with ANTLR though.
     */
    public SimpleNode parse(InputStream stream) throws ParseException
    {
        token_source.clearStateVars();
        ReInit(stream);  
        return process();
    }        

    public void setDirectives(Hashtable directives)
    {
        this.directives = directives;
    }

    public Directive getDirective(String directive)
    {
        return (Directive) directives.get(directive);
    }

    public boolean isDirective(String directive)
    {
        if (directives.containsKey(directive))
            return true;
        else
            return false;
    }            
}

PARSER_END(Parser)

/**
 * This gets inserted into the ParserMacroTokenManager
 * and is being used here strictly for the #parse
 * directive: an #include type behaviour. We have
 * to save the state the stream currently being
 * parsed and we have to save the state of the
 * lexer (TokenManager class) then we create
 * a new stream from the file named in the
 * #parse directive then we ReInit the lexer. 
 * Whatever it parses will get placed 
 * into the AST.
 *
 * I need a simple way to detect circular
 * inclusions so this thing doesn't go wild
 * and drag down the VM.
 */
TOKEN_MGR_DECLS: 
{  
    private boolean incMode;
    private int fileDepth = 0;

    private int lparen = 0;
    private int rparen = 0;

    /*
     * gmj : make sure this is reset before each parse
     */
    Stack stateStack = new Stack();
    public boolean bDebugPrint_ = false;

    private boolean inReference;
    public boolean inDirective;
    private boolean inComment;
    private boolean inSet;

    Stack streams = new Stack();
    Stack states = new Stack();
    
    // remove double quotes in the string
    String stripQuotes(String str) 
    {
        int start = str.indexOf("\"");
        int end = str.indexOf("\"",start+1);    
        return str.substring(start+1,end);
    }    
    
    /**
     * Save the state of the current input stream
     * and the state of the lexer. So we can process
     * the new one.
     */
    void pushFile(String filename)
    {
        fileDepth++;
        
        streams.push(input_stream);
        states.push(new Integer(curLexState));
        
        try
        {
            FileInputStream fs = new FileInputStream(filename);
            ASCII_CharStream new_stream = new ASCII_CharStream(fs,1,1);    
            ReInit(new_stream);
        }
        catch(Exception e)
        {
        }
    }    
  
    /**
     * Retrieve the oldStream and oldState and
     * continue processing the input.
     */
    void popFile()
    {
        ReInit((ASCII_CharStream) streams.pop(), ((Integer) states.pop()).intValue());
        fileDepth--;
    }    
    
    private boolean AtParent()
    {
        if (fileDepth == 0)
            return true;
        else
            return false;
    }
    
    void CommonTokenAction(Token t)
    {
        if (t.kind == EOF && ! AtParent())
        {
            Token new_t;
            popFile();
            new_t = getNextToken();
            t.kind = new_t.kind;
            t.beginLine = new_t.beginLine;
            t.beginColumn = new_t.beginColumn;
            t.endLine = new_t.endLine;
            t.endColumn = new_t.endColumn;
            t.image = new_t.image;
            t.next = new_t.next;
            t.specialToken = new_t.specialToken;
        }
    } 

    /**
     *  pushes the current state onto the 'state stack',
     *  and maintains the parens counts
     *  public because we need it in PD & VM handling
     *
     *  @return boolean : success.  It can fail if the state machine
     *     gets messed up.
     */
    public boolean stateStackPop()
    {
      
        Hashtable hStack;

        try
        {
            hStack = (Hashtable) stateStack.pop();
        }
        catch( EmptyStackException e)
        {
            lparen=0;
            SwitchTo(DEFAULT);
            return false;
        }

        if( bDebugPrint_ )
            System.out.println(" stack pop (" + stateStack.size() + ") : lparen=" + ( (Integer) hStack.get("lparen")).intValue() 
                + " newstate=" +  ( (Integer)  hStack.get("lexstate")).intValue() );
       
        lparen = ( (Integer) hStack.get("lparen")).intValue();
        rparen = ( (Integer) hStack.get("rparen")).intValue();
        SwitchTo( ( (Integer) hStack.get("lexstate")).intValue() ); 
    
        return true;
    }

    /**
     *  pops a state off the stack, and restores paren counts
     *
     *  @return boolean : success of operation
     */
    public boolean stateStackPush()
    {
        if( bDebugPrint_ )
            System.out.println(" (" + stateStack.size() + ") pushing cur state : " + curLexState );
            
        Hashtable hStack = new Hashtable();
        hStack.put("lexstate", new Integer( curLexState ) );
        hStack.put("lparen", new Integer( lparen ));
        hStack.put("rparen", new Integer( rparen ));
        lparen = 0;

        stateStack.push( hStack );

        return true;
    }

    /**
     *  Clears all state variables, resets to
     *  start values, clears stateStack.  Call
     *  before parsing.
     *  @return void
     */   
    public void clearStateVars()
    {
        stateStack.clear();
        
        lparen = 0;
        rparen = 0;
        inReference = false;
        inDirective = false;
        inComment = false;
        inSet = false;
        
        return;
    }
} 

/* ------------------------------------------------------------------------
 *
 * Tokens
 *
 *  Note : we now have another state, REFMODIFIER.  This is sort of a 
 *  type of REFERENCE state, simply use to use the DIRECTIVE token
 *  set when we are processing a $foo.bar() construct
 *
 * ------------------------------------------------------------------------- */

<DIRECTIVE,REFMODIFIER,REFMOD2>
TOKEN:
{ 
    <LBRACKET: "[">
|   <RBRACKET: "]">
}

<DIRECTIVE,REFMOD2>
TOKEN:
{
    <COMMA:",">
}


<DIRECTIVE,REFMODIFIER,REFMOD2>
TOKEN:
{
    <LPAREN: "(">
    {
        if (!inComment)
            lparen++;

        /*
         *  if we have seen the dot, then move to REFMOD2 -> Modifier()
         */

        if (curLexState == REFMODIFIER )
            SwitchTo( REFMOD2 );

    }

|   <RPAREN: ")">
    {
        /*
         *  Ultimately, we want to drop down to the state below the one that has an open (
         *  if we hit bottom (DEFAULT), that's fine. It's just text schmoo.
         *
         */
    
     
        boolean bClosed = false;

        if (inComment)
            bClosed = true;

        while( !bClosed) 
        {
            /*
             * look at current state.  If we haven't seen a lparen in this state
             * then we drop a state, because this lparen clearly closes our state
             */

            if( lparen > 0)
            {
                /*
                 *  if rparen + 1 == lparen, then this state is closed. Otherwise, increment
                 *  and keep parsing
                 */

                 if( lparen == rparen + 1)
                 {
                       stateStackPop();
                 }  
                else
                {   
                    rparen++;
                }
                      
                 bClosed = true;
            }
            else
            {
                /*
                 * now, drop a state
                 */
        
                if(!stateStackPop())
                    break;
            } 
        }
    }    
}


TOKEN :
{
    <ESCAPE_SEQUENCE: "\\" ~[] >
|   <TEXT: (~["$", "#", "\\"])+ >
}    

<*>
MORE :
{
    //
    //  Note : DOLLARBANG is a duplicate of DOLLAR.  They must be identical.
    //

    <DOLLAR: "$"> 
    { 
        if (! inComment)
        {
            inReference = true;

           if ( bDebugPrint_ )
                System.out.print( "$  : going to " + REFERENCE );

            stateStackPush();
            SwitchTo(REFERENCE);
        }            
    }

|   <DOLLARBANG: "$!"> 
    { 
        if (! inComment)
        {
            inReference = true;

           if ( bDebugPrint_ )
                System.out.print( "$!  : going to " + REFERENCE );

            stateStackPush();
            SwitchTo(REFERENCE);
        }            
    }

|   "##"
   { 
        inComment = true;
        stateStackPush();
        SwitchTo(IN_SINGLE_LINE_COMMENT);
     }

|   <"#**" ~["#"]> 
    { 
        input_stream.backup(1); 
        inComment = true; 
        stateStackPush();
        SwitchTo( IN_FORMAL_COMMENT);
        // was : IN_FORMAL_COMMENT
    } 
    
|   "#*" 
    { 
        inComment=true;
        stateStackPush();
        SwitchTo( IN_MULTI_LINE_COMMENT ); 
    } 


|   <HASH : "#"> 
  { 
        if (! inComment)
        {
            inDirective = true;

            if ( bDebugPrint_ )
                System.out.print("# :  going to " + DIRECTIVE );
            
            stateStackPush();
            SwitchTo(DIRECTIVE);
        }
    } 
}   

// -----------------------------------------------------------------------
// 
// COMMENT Lexical States
// 
// -----------------------------------------------------------------------

<IN_SINGLE_LINE_COMMENT>
TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > 
  { 
     inComment = false;
     stateStackPop();
    // was :DEFAULT
  } 

}

<IN_FORMAL_COMMENT>
TOKEN :
{
  <FORMAL_COMMENT: "*#" > 
  {     
    inComment = false;
    stateStackPop();
    // was :DEFAULT
  } 
}

<IN_MULTI_LINE_COMMENT>
TOKEN :
{
  <MULTI_LINE_COMMENT: "*#" > 
  { 
    inComment = false; 
    stateStackPop();
    // was :DEFAULT
  } 
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

// -----------------------------------------------------------------------
// 
// DIRECTIVE Lexical State
// 
// -----------------------------------------------------------------------

<DIRECTIVE,REFMOD2> 
SKIP:
{
    " "
|   "\t"
//|   "\n"
//|   "\r"
}

<REFERENCE,DIRECTIVE,REFMODIFIER,REFMOD2>
TOKEN :
{

   <STRING_LITERAL: ( "\"" ( ~["\"","\n","\r"] )* "\"" ) >
    {
        if (incMode)
        {
            matchedToken.image = stripQuotes(image.toString());
            pushFile(matchedToken.image);
        }
        incMode = false;
    
        if (lparen == 0)
            SwitchTo(DEFAULT);
    }

|   <TRUE: "true">
|   <FALSE: "false">
}

<DIRECTIVE>
SPECIAL_TOKEN :
{
    <NEWLINE: "\n" | "\r" | "\r\n" >
    {
        if (inSet)
       {
           if ( bDebugPrint_ )
                System.out.print(" NEWLINE :");
            stateStackPop();        
           inSet = false;
           inDirective = false;
        }
   }        
}    

<DIRECTIVE>
TOKEN : 
{
    <MINUS: "-">
|   <PLUS: "+">
|   <MULTIPLY: "*">
|   <DIVIDE: "/">
|   <MODULUS: "%">
|   <LOGICAL_AND: "&&">
|   <LOGICAL_OR: "||">
|   <LOGICAL_LT: "<">
|   <LOGICAL_LE: "<=">
|   <LOGICAL_GT: ">">
|   <LOGICAL_GE: ">=">
|   <LOGICAL_EQUALS: "==">
|   <LOGICAL_NOT_EQUALS: "!=">
|   <LOGICAL_NOT: "!">
|   <EQUALS: "=" >
}

<DIRECTIVE> 
TOKEN :
{
    <END: "end"> 
    { 
        inDirective = false; 
        stateStackPop();
        // was :DEFAULT
    } 

|   <INCLUDE_DIRECTIVE: "include"> 
    { incMode = true; }

|   <IF_DIRECTIVE: "if">

|   <ELSEIF_DIRECTIVE: "elseif">

|   <ELSE_DIRECTIVE: "else"> 
    : DEFAULT

|   <SET_DIRECTIVE: "set" >
    { inSet = true; }

|   <STOP_DIRECTIVE: "stop">
    {
        matchedToken.kind = EOF;
        fileDepth = 0;
    }

|   <#DIGIT: [ "0"-"9" ] >
|   <NUMBER_LITERAL: (<DIGIT>)+ >
    {
        //!!! fixed <bcolor="#333333"/>
        // needs to be more thorough.
        if (lparen == 0)
            SwitchTo(DEFAULT);
    }            
    
    //!!! fixed #FFFFFF
|   <#LETTER: [ "a"-"z", "A" - "Z" ] >
|   <WORD: (<LETTER>)+ >
}


// -----------------------------------------------------------------------
// 
// REFERENCE Lexical State
// 
// -----------------------------------------------------------------------

<REFERENCE,REFMODIFIER,REFMOD2> 
TOKEN :
{
    <#ALPHA_CHAR: ["a"-"z", "A"-"Z"] >
|   <#ALPHANUM_CHAR: [ "a"-"z", "A"-"Z", "0"-"9" ] >
|   <#IDENTIFIER_CHAR: [ "a"-"z", "A"-"Z", "0"-"9", "-", "_" ] >
|   <IDENTIFIER:  <ALPHA_CHAR> (<IDENTIFIER_CHAR>)* >
|   <DOT: ".">
    {
        if ( bDebugPrint_ )
            System.out.print("DOT : switching to " + REFMODIFIER);
        SwitchTo(REFMODIFIER);
    }
|   <LCURLY: "{">
|   <RCURLY: "}">
    {
        // was :DEFAULT
        stateStackPop();
    }
}

<REFERENCE,REFMODIFIER,REFMOD2> 
SPECIAL_TOKEN :
{
    <REFERENCE_TERMINATOR: ~[] >
    {   
        /*
         *  These can terminate a reference, but are needed in subsequent states
         */

        if (image.toString().equals("="))
        {
            input_stream.backup(1);
        } 
                
        inReference = false;
    
        if ( bDebugPrint_ )
            System.out.print("REF_TERM :");
        
        stateStackPop();

        /*
         *  I removed LPAREN & RPAREN from REFERENCE;  as there is no LPAREN,RPAREN in REF is there is REFMETHOD
         */
        
        if (curLexState != DEFAULT && ( image.toString().equals(")") 
                                        || image.toString().equals(",") 
                                        || image.toString().equals("[") 
                                        || image.toString().equals("]")
                                        || image.toString().equals("\n")
                                        ) )
        {
            input_stream.backup(1);
        }

    }
}

/**
 * This method is what starts the whole parsing
 * process. After the parsing is complete and
 * the template has been turned into an AST,
 * this method returns the root of AST which
 * can subsequently be traversed by a visitor
 * which implements the ParserVisitor interface
 * which is generated automatically by JavaCC
 */
SimpleNode process() : {/*@bgen(jjtree) process */
  ASTprocess jjtn000 = new ASTprocess(this, JJTPROCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) process */
   try {
/*@egen*/
   ( Statement() )* <EOF>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return jjtn000; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

// -----------------------------------------------------------------------
// 
// Statement Syntax
// 
// -----------------------------------------------------------------------

/**
 * These are the types of statements that
 * are acceptable in Velocity templates.
 * I have not found that the order here
 * matters much. Someone please correct
 * me here if I'm wrong.
 */

void Statement()       : {}
{
   IfStatement()
|   IncludeStatement()
|   StopStatement()
|   Reference()
|   Comment()
|   SetDirective()
|   Directive()
|   Text()
}

void Comment() : {/*@bgen(jjtree) Comment */
  ASTComment jjtn000 = new ASTComment(this, JJTCOMMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Comment */
    try {
/*@egen*/
    <SINGLE_LINE_COMMENT>
|   <MULTI_LINE_COMMENT>
|   <FORMAL_COMMENT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NumberLiteral() : {/*@bgen(jjtree) NumberLiteral */
  ASTNumberLiteral jjtn000 = new ASTNumberLiteral(this, JJTNUMBERLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NumberLiteral */
    try {
/*@egen*/
    <NUMBER_LITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

void StringLiteral() : {/*@bgen(jjtree) StringLiteral */
  ASTStringLiteral jjtn000 = new ASTStringLiteral(this, JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StringLiteral */
    try {
/*@egen*/
    <STRING_LITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

/**
 * This method corresponds to variable
 * references in Velocity templates.
 * The following are examples of variable
 * references that may be found in a
 * template:
 *
 * $foo
 * $bar
 *
 */
void Identifier() : {/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/    
    <IDENTIFIER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Word() : {/*@bgen(jjtree) Word */
  ASTWord jjtn000 = new ASTWord(this, JJTWORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Word */
    try {
/*@egen*/
    <WORD>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

void DirectiveArg()       : {}
{
    Reference()
|   Word()  
|   StringLiteral()
|   NumberLiteral()
|   ObjectArray()
}

SimpleNode Directive() : 
{/*@bgen(jjtree) Directive */
    ASTDirective jjtn000 = new ASTDirective(this, JJTDIRECTIVE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
    Directive d;
}
{/*@bgen(jjtree) Directive */
    try {
/*@egen*/
    t = <WORD>
    {
        d = (Directive) directives.get(t.image.substring(1));
        
        if (d == null)
        {
            token_source.stateStackPop();
            token_source.inDirective = false;
            return jjtn000;
        }            
    }

    <LPAREN> (DirectiveArg())+ <RPAREN>
    {
        if (d.getType() == Directive.LINE)
            return jjtn000;
    }/*@bgen(jjtree) Block */
    {
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    
    ( Statement() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ 
    <END>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}    

void ObjectArray() : {/*@bgen(jjtree) ObjectArray */
  ASTObjectArray jjtn000 = new ASTObjectArray(this, JJTOBJECTARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectArray */
    try {
/*@egen*/
    <LBRACKET> [ Parameter() ( <COMMA> Parameter() )* ] <RBRACKET>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * This method has yet to be fully implemented
 * but will allow arbitrarily nested method
 * calls
 */
void Parameter()      : {}
{
    StringLiteral()
|   ObjectArray()
|   True()
|   False()
|   Reference() 
}

/**
 * This method has yet to be fully implemented
 * but will allow arbitrarily nested method
 * calls
 */
void Method() : {/*@bgen(jjtree) Method */
  ASTMethod jjtn000 = new ASTMethod(this, JJTMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Method */
    try {
/*@egen*/
    Identifier() <LPAREN> [ Parameter() ( <COMMA> Parameter() )* ] <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Reference() : {/*@bgen(jjtree) Reference */
  ASTReference jjtn000 = new ASTReference(this, JJTREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Reference */
    try {
/*@egen*/ 

    // This should be changed to Indentifier() now. Make
    // it easier to walk the AST.
    [<LCURLY>]
    <IDENTIFIER>
    [<RCURLY>]
    (LOOKAHEAD(2) <DOT> (LOOKAHEAD(3) Method() | Identifier() ) [<RCURLY>] )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void True() : {/*@bgen(jjtree) True */
  ASTTrue jjtn000 = new ASTTrue(this, JJTTRUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) True */
    try {
/*@egen*/
    <TRUE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void False() : {/*@bgen(jjtree) False */
  ASTFalse jjtn000 = new ASTFalse(this, JJTFALSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) False */
    try {
/*@egen*/
    <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * This method is responsible for allowing
 * all non-grammar text to pass through
 * unscathed.
 */
void Text() : 
{/*@bgen(jjtree) Text */
    ASTText jjtn000 = new ASTText(this, JJTTEXT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Text */
    try {
/*@egen*/
    <TEXT>
|   <DOT>
|   <RPAREN>
|   <LPAREN>
|   <NUMBER_LITERAL>
|   <STRING_LITERAL>
|   t = <ESCAPE_SEQUENCE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        t.image = t.image.substring(1);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/        
}

// -----------------------------------------------------------------------
// 
// Directive Syntax
// 
// -----------------------------------------------------------------------

void IfStatement() : {/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatement */
     try {
/*@egen*/
     <IF_DIRECTIVE> <LPAREN> Expression() <RPAREN>/*@bgen(jjtree) Block */
    {
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( Statement() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/
    [ LOOKAHEAD(1) ( ElseIfStatement() )+ ]
    [ LOOKAHEAD(1) ElseStatement() ]
    <END>/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}

void ElseStatement() : {/*@bgen(jjtree) ElseStatement */
  ASTElseStatement jjtn000 = new ASTElseStatement(this, JJTELSESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ElseStatement */
    try {
/*@egen*/
    <ELSE_DIRECTIVE>/*@bgen(jjtree) Block */
    {
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/ 
    ( Statement() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*//*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ElseIfStatement() : {/*@bgen(jjtree) ElseIfStatement */
  ASTElseIfStatement jjtn000 = new ASTElseIfStatement(this, JJTELSEIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ElseIfStatement */
    try {
/*@egen*/
    <ELSEIF_DIRECTIVE> 
    <LPAREN> Expression() <RPAREN>/*@bgen(jjtree) Block */
    {
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( Statement() )+/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*//*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SetDirective() : {/*@bgen(jjtree) SetDirective */
  ASTSetDirective jjtn000 = new ASTSetDirective(this, JJTSETDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SetDirective */
    try {
/*@egen*/
    <SET_DIRECTIVE> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}    

/**
 * This method corresponds to an #include
 * directive in a Velocity template. The
 * following are examples of #include
 * constructs that are acceptable in
 * a template:
 *
 * #include "foo.inc" 
 */
void IncludeStatement()      : {}
{
    <INCLUDE_DIRECTIVE> <STRING_LITERAL>
}

/**
 * This method corresponds to the #stop
 * directive which just simulates and EOF
 * so that parsing stops. The #stop directive
 * is really only useful for debugging
 * purposes.
 */
void StopStatement()      : {}
{    
    <STOP_DIRECTIVE>
}

// -----------------------------------------------------------------------
// 
// Expression Syntax
// 
// -----------------------------------------------------------------------

void Expression() : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    LOOKAHEAD( PrimaryExpression() <EQUALS> ) Assignment()
|   ConditionalOrExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Assignment()                : {/*@bgen(jjtree) #Assignment( 2) */
  ASTAssignment jjtn000 = new ASTAssignment(this, JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #Assignment( 2) */
    try {
/*@egen*/
    PrimaryExpression() <EQUALS> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  2);
      }
    }
/*@egen*/
}

void ConditionalOrExpression()       : {}
{
  ConditionalAndExpression()
  ( <LOGICAL_OR>/*@bgen(jjtree) #OrNode( 2) */
                 {
                   ASTOrNode jjtn001 = new ASTOrNode(this, JJTORNODE);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                 }
                 try {
/*@egen*/ ConditionalAndExpression()/*@bgen(jjtree)*/
                 } catch (Throwable jjte001) {
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte001 instanceof ParseException) {
                     throw (ParseException)jjte001;
                   }
                   if (jjte001 instanceof RuntimeException) {
                     throw (RuntimeException)jjte001;
                   }
                   throw (Error)jjte001;
                 } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  2);
                   }
                 }
/*@egen*/ )*
}


void ConditionalAndExpression()       : {}
{
  EqualityExpression()
  ( <LOGICAL_AND>/*@bgen(jjtree) #AndNode( 2) */
                   {
                     ASTAndNode jjtn001 = new ASTAndNode(this, JJTANDNODE);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                   }
                   try {
/*@egen*/  EqualityExpression()/*@bgen(jjtree)*/
                   } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof ParseException) {
                       throw (ParseException)jjte001;
                     }
                     if (jjte001 instanceof RuntimeException) {
                       throw (RuntimeException)jjte001;
                     }
                     throw (Error)jjte001;
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  2);
                     }
                   }
/*@egen*/ )*
}

void EqualityExpression()       : {}
{
    RelationalExpression()
    (
          <LOGICAL_EQUALS>/*@bgen(jjtree) #EQNode( 2) */
                           {
                             ASTEQNode jjtn001 = new ASTEQNode(this, JJTEQNODE);
                             boolean jjtc001 = true;
                             jjtree.openNodeScope(jjtn001);
                           }
                           try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
                           } catch (Throwable jjte001) {
                             if (jjtc001) {
                               jjtree.clearNodeScope(jjtn001);
                               jjtc001 = false;
                             } else {
                               jjtree.popNode();
                             }
                             if (jjte001 instanceof ParseException) {
                               throw (ParseException)jjte001;
                             }
                             if (jjte001 instanceof RuntimeException) {
                               throw (RuntimeException)jjte001;
                             }
                             throw (Error)jjte001;
                           } finally {
                             if (jjtc001) {
                               jjtree.closeNodeScope(jjtn001,  2);
                             }
                           }
/*@egen*/
        | <LOGICAL_NOT_EQUALS>/*@bgen(jjtree) #NENode( 2) */
                               {
                                 ASTNENode jjtn002 = new ASTNENode(this, JJTNENODE);
                                 boolean jjtc002 = true;
                                 jjtree.openNodeScope(jjtn002);
                               }
                               try {
/*@egen*/ RelationalExpression()/*@bgen(jjtree)*/
                               } catch (Throwable jjte002) {
                                 if (jjtc002) {
                                   jjtree.clearNodeScope(jjtn002);
                                   jjtc002 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte002 instanceof ParseException) {
                                   throw (ParseException)jjte002;
                                 }
                                 if (jjte002 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte002;
                                 }
                                 throw (Error)jjte002;
                               } finally {
                                 if (jjtc002) {
                                   jjtree.closeNodeScope(jjtn002,  2);
                                 }
                               }
/*@egen*/
    )*
}

void RelationalExpression()       : {}
{
    AdditiveExpression()
    (
          <LOGICAL_LT>/*@bgen(jjtree) #LTNode( 2) */
                       {
                         ASTLTNode jjtn001 = new ASTLTNode(this, JJTLTNODE);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
                       }
                       try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte001) {
                         if (jjtc001) {
                           jjtree.clearNodeScope(jjtn001);
                           jjtc001 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte001 instanceof ParseException) {
                           throw (ParseException)jjte001;
                         }
                         if (jjte001 instanceof RuntimeException) {
                           throw (RuntimeException)jjte001;
                         }
                         throw (Error)jjte001;
                       } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  2);
                         }
                       }
/*@egen*/
        | <LOGICAL_GT>/*@bgen(jjtree) #GTNode( 2) */
                       {
                         ASTGTNode jjtn002 = new ASTGTNode(this, JJTGTNODE);
                         boolean jjtc002 = true;
                         jjtree.openNodeScope(jjtn002);
                       }
                       try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte002) {
                         if (jjtc002) {
                           jjtree.clearNodeScope(jjtn002);
                           jjtc002 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte002 instanceof ParseException) {
                           throw (ParseException)jjte002;
                         }
                         if (jjte002 instanceof RuntimeException) {
                           throw (RuntimeException)jjte002;
                         }
                         throw (Error)jjte002;
                       } finally {
                         if (jjtc002) {
                           jjtree.closeNodeScope(jjtn002,  2);
                         }
                       }
/*@egen*/
        | <LOGICAL_LE>/*@bgen(jjtree) #LENode( 2) */
                       {
                         ASTLENode jjtn003 = new ASTLENode(this, JJTLENODE);
                         boolean jjtc003 = true;
                         jjtree.openNodeScope(jjtn003);
                       }
                       try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte003) {
                         if (jjtc003) {
                           jjtree.clearNodeScope(jjtn003);
                           jjtc003 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte003 instanceof ParseException) {
                           throw (ParseException)jjte003;
                         }
                         if (jjte003 instanceof RuntimeException) {
                           throw (RuntimeException)jjte003;
                         }
                         throw (Error)jjte003;
                       } finally {
                         if (jjtc003) {
                           jjtree.closeNodeScope(jjtn003,  2);
                         }
                       }
/*@egen*/
        | <LOGICAL_GE>/*@bgen(jjtree) #GENode( 2) */
                       {
                         ASTGENode jjtn004 = new ASTGENode(this, JJTGENODE);
                         boolean jjtc004 = true;
                         jjtree.openNodeScope(jjtn004);
                       }
                       try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                       } catch (Throwable jjte004) {
                         if (jjtc004) {
                           jjtree.clearNodeScope(jjtn004);
                           jjtc004 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte004 instanceof ParseException) {
                           throw (ParseException)jjte004;
                         }
                         if (jjte004 instanceof RuntimeException) {
                           throw (RuntimeException)jjte004;
                         }
                         throw (Error)jjte004;
                       } finally {
                         if (jjtc004) {
                           jjtree.closeNodeScope(jjtn004,  2);
                         }
                       }
/*@egen*/
    )*
}

void AdditiveExpression()       : {}
{
    MultiplicativeExpression()
    (
          <PLUS>/*@bgen(jjtree) #AddNode( 2) */
                  {
                    ASTAddNode jjtn001 = new ASTAddNode(this, JJTADDNODE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*/  MultiplicativeExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof ParseException) {
                      throw (ParseException)jjte001;
                    }
                    if (jjte001 instanceof RuntimeException) {
                      throw (RuntimeException)jjte001;
                    }
                    throw (Error)jjte001;
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  2);
                    }
                  }
/*@egen*/
        | <MINUS>/*@bgen(jjtree) #SubtractNode( 2) */
                  {
                    ASTSubtractNode jjtn002 = new ASTSubtractNode(this, JJTSUBTRACTNODE);
                    boolean jjtc002 = true;
                    jjtree.openNodeScope(jjtn002);
                  }
                  try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte002) {
                    if (jjtc002) {
                      jjtree.clearNodeScope(jjtn002);
                      jjtc002 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte002 instanceof ParseException) {
                      throw (ParseException)jjte002;
                    }
                    if (jjte002 instanceof RuntimeException) {
                      throw (RuntimeException)jjte002;
                    }
                    throw (Error)jjte002;
                  } finally {
                    if (jjtc002) {
                      jjtree.closeNodeScope(jjtn002,  2);
                    }
                  }
/*@egen*/
    )*
}

void MultiplicativeExpression()       : {}
{
    UnaryExpression()
    (
          <MULTIPLY>/*@bgen(jjtree) #MulNode( 2) */
                     {
                       ASTMulNode jjtn001 = new ASTMulNode(this, JJTMULNODE);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                     }
                     try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
                     } catch (Throwable jjte001) {
                       if (jjtc001) {
                         jjtree.clearNodeScope(jjtn001);
                         jjtc001 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte001 instanceof ParseException) {
                         throw (ParseException)jjte001;
                       }
                       if (jjte001 instanceof RuntimeException) {
                         throw (RuntimeException)jjte001;
                       }
                       throw (Error)jjte001;
                     } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  2);
                       }
                     }
/*@egen*/
        | <DIVIDE>/*@bgen(jjtree) #DivNode( 2) */
                     {
                       ASTDivNode jjtn002 = new ASTDivNode(this, JJTDIVNODE);
                       boolean jjtc002 = true;
                       jjtree.openNodeScope(jjtn002);
                     }
                     try {
/*@egen*/   UnaryExpression()/*@bgen(jjtree)*/
                     } catch (Throwable jjte002) {
                       if (jjtc002) {
                         jjtree.clearNodeScope(jjtn002);
                         jjtc002 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte002 instanceof ParseException) {
                         throw (ParseException)jjte002;
                       }
                       if (jjte002 instanceof RuntimeException) {
                         throw (RuntimeException)jjte002;
                       }
                       throw (Error)jjte002;
                     } finally {
                       if (jjtc002) {
                         jjtree.closeNodeScope(jjtn002,  2);
                       }
                     }
/*@egen*/
        | <MODULUS>/*@bgen(jjtree) #ModNode( 2) */
                     {
                       ASTModNode jjtn003 = new ASTModNode(this, JJTMODNODE);
                       boolean jjtc003 = true;
                       jjtree.openNodeScope(jjtn003);
                     }
                     try {
/*@egen*/  UnaryExpression()/*@bgen(jjtree)*/
                     } catch (Throwable jjte003) {
                       if (jjtc003) {
                         jjtree.clearNodeScope(jjtn003);
                         jjtc003 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte003 instanceof ParseException) {
                         throw (ParseException)jjte003;
                       }
                       if (jjte003 instanceof RuntimeException) {
                         throw (RuntimeException)jjte003;
                       }
                       throw (Error)jjte003;
                     } finally {
                       if (jjtc003) {
                         jjtree.closeNodeScope(jjtn003,  2);
                       }
                     }
/*@egen*/
    )*
}

void UnaryExpression()       : {}
{
    <LOGICAL_NOT>/*@bgen(jjtree) #NotNode( 1) */
                  {
                    ASTNotNode jjtn001 = new ASTNotNode(this, JJTNOTNODE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof ParseException) {
                      throw (ParseException)jjte001;
                    }
                    if (jjte001 instanceof RuntimeException) {
                      throw (RuntimeException)jjte001;
                    }
                    throw (Error)jjte001;
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  1);
                    }
                  }
/*@egen*/
|   PrimaryExpression()
}

void PrimaryExpression()       : {}
{    
    StringLiteral()
|   NumberLiteral()    
|   Reference()
|   ObjectArray()
|   True()
|   False()
|   <LPAREN> Expression() <RPAREN>
}
