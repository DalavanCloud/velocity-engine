/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package org.apache.velocity.runtime.parser;

import java.io.Writer;
import java.io.IOException;

import org.apache.velocity.Context;

public class SimpleNode implements Node
{
    protected Node parent;
    protected Node[] children;
    protected int id;
    protected Parser parser;
    
    protected  int info; // added
    public boolean state;
    
    
    /* Added */
    protected Token first, last;

    public SimpleNode(int i)
    {
        id = i;
    }

    public SimpleNode(Parser p, int i)
    {
        this(i);
        parser = p;
    }

    /* Added */
    public void interpret()
    {
    }

    public void jjtOpen()
    {
        first = parser.getToken(1); // added
    }

    public void jjtClose()
    {
        last = parser.getToken(0); // added
    }

    public void setFirstToken(Token t)
    {
        this.first = first;
    }

    public Token getFirstToken()
    {
        return first;
    }
    public Token getLastToken()
    {
        return last;
    }

    public void jjtSetParent(Node n)
    {
        parent = n;
    }
    public Node jjtGetParent()
    {
        return parent;
    }

    public void jjtAddChild(Node n, int i)
    {
        if (children == null)
        {
            children = new Node[i + 1];
        }
        else if (i >= children.length)
        {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }

    public Node jjtGetChild(int i)
    {
        return children[i];
    }

    public int jjtGetNumChildren()
    {
        return (children == null) ? 0 : children.length;
    }

    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }

    /** Accept the visitor. **/
    public Object childrenAccept(ParserVisitor visitor, Object data)
    {
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                children[i].jjtAccept(visitor, data);
            }
        }
        return data;
    }

    /* You can override these two methods in subclasses of SimpleNode to
        customize the way the node appears when the tree is dumped.  If
        your output uses more than one line you should override
        toString(String), otherwise overriding toString() is probably all
        you need to do. */

    public String toString()
    {
        return ParserTreeConstants.jjtNodeName[id];
    }
    public String toString(String prefix)
    {
        return prefix + toString();
    }

    /* Override this method if you want to customize how the node dumps
        out its children. */

    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    // All additional methods

    public Object init(Context context, Object data) throws Exception
    {
        int i, k = jjtGetNumChildren();

        for (i = 0; i < k; i++)
            jjtGetChild(i).init(context, data);
    
        return data;
    }

    public boolean evaluate(Context context)
    {
        return false;
    }        

    public Object value(Context context)
    {
        return null;
    }        

    public void render(Context context, Writer writer)
        throws IOException
    {
    }

    public Object execute(Object o, Context context)
    {
        return null;
    }

    public int getType()
    {
        return id;
    }

    public void setInfo(int info)
    {
        this.info = info;
    }
    
    public int getInfo()
    {
        return info;
    }        
}

