/* Generated By:JJTree: Do not edit this line. ASTIdentifier.java */

package org.apache.velocity.runtime.parser;

import java.util.Map;
import java.lang.reflect.Method;

import org.apache.velocity.Context;
import org.apache.velocity.util.ClassUtils;

public class ASTIdentifier extends SimpleNode
{
    private AbstractExecutor executor;
    
    public ASTIdentifier(int id)
    {
        super(id);
    }

    public ASTIdentifier(Parser p, int id)
    {
        super(p, id);
    }

    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }

    public Object init(Context context, Object data)
        throws Exception
    {
        String identifier = getFirstToken().image;
        String method = "get" + identifier;

        //! Now there might just be an error here.
        //  If there is a typo in the property
        //  then a MapExecutor is created and
        //  this needs to be prevented.

        try
        {
            executor = new PropertyExecutor();
            Method m = ((Class)data).getMethod(method,null);
            executor.setData(m);
            return m.getReturnType();
        }
        catch (NoSuchMethodException nsme)
        {
            executor = new MapExecutor();
            executor.setData(identifier);
            return Object.class;
        }
    }

    public Object execute(Object o, Context context)
    {
        return executor.execute(o, context);
    }

    public Object invoke(Object result, Context context)
    {
        String identifier = getFirstToken().image;
        String method = "get" + identifier;
        Object newResult;
        
        newResult = ClassUtils.invoke(result, method);
        if (newResult == null)
        {
            method = "get";
            Object[] args = { identifier };
            Class[] ptypes = null;

            // Have to make sure class types are
            // correct for a proper signature match.

            if (result instanceof Map)
            {
                // This can be created once.
                ptypes = new Class[1];
                ptypes[0] = new Object().getClass();
            }

            result = ClassUtils.invoke(result, method, args, ptypes);
        }
        else
            result = newResult;
        
        return result;
    }
}
