/* Generated By:JJTree: Do not edit this line. ASTReference.java */

/*
 * The Apache Software License, Version 1.1
 *
 * Copyright (c) 2000 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowlegement:
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowlegement may appear in the software itself,
 *    if and wherever such third-party acknowlegements normally appear.
 *
 * 4. The names "The Jakarta Project", "Tomcat", and "Apache Software
 *    Foundation" must not be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache"
 *    nor may "Apache" appear in their names without prior written
 *    permission of the Apache Group.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */


/**
 * This class is responsible for handling the references in
 * VTL ($foo).
 * 
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href="mailto:jvanzyl@periapt.com">Jason van Zyl</a>
 * @author <a href="mailto:geirm@optonline.net">Geir Magnusson Jr.</a>
 * @version $Id: ASTReference.java,v 1.13 2000/12/05 05:01:27 geirm Exp $ 
*/

package org.apache.velocity.runtime.parser.node;

import java.io.Writer;
import java.io.IOException;
import java.util.Map;
import java.lang.reflect.Method;

import org.apache.velocity.Context;
import org.apache.velocity.runtime.Runtime;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.exception.ReferenceException;
import org.apache.velocity.runtime.parser.*;

public class ASTReference extends SimpleNode
{
    /* Reference types */
    private static final int NORMAL_REFERENCE = 1;
    private static final int FORMAL_REFERENCE = 2;
    private static final int QUIET_REFERENCE = 3;
    
    private int referenceType;
    private String nullString;
    private String rootString;
    private boolean bIsEscaped_ = false;
    private String  strPrefix_ = "";

    public ASTReference(int id)
    {
        super(id);
    }

    public ASTReference(Parser p, int id)
    {
        super(p, id);
    }

    /** Accept the visitor. **/
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }

    public Object init(Context context, Object data) throws Exception
    {
        /*
         *  init our children
         */

        super.init( context, data );

        /*
         *  the only thing we can do in init() is getRoot()
         *  as that is template based, not context based,
         *  so it's thread- and context-safe
         */

        rootString = getRoot();

        return data;
    }        
    
    /**
     *   gets an Object that 'is' the value of the reference
     *
     *   @param o   unused Object parameter
     *   @param context context used to generate value
     */
    public Object execute(Object o, Context context)
    {   
        /*
         *  get the root object from the context
         */

        Object result = getVariableValue(context, rootString);
        
        if (result == null)
            return null;

        /*
         *  iteratively work 'down' (it's flat...) the reference
         *  to get the value
         */

        int children = jjtGetNumChildren();
        
        for (int i = 0; i < children; i++)
            result = jjtGetChild(i).execute(result,context);
    
        return result;
    }

    /**
     *  gets the value of the reference and outputs it to the
     *  writer.
     *
     *  @param context  context of data to use in getting value
     *  @param writer   writer to render to
     */
    public boolean render(Context context, Writer writer)
        throws IOException
    {
        Object value = execute(null, context);
        
        /*
         *  if this reference is escaped (\$foo) then we want to do one of two things :
         *  1) if this is a reference in the context, then we want to print $foo
         *  2) if not, then \$foo  (its considered shmoo, not VTL)
         */

        if (bIsEscaped_)
        {
            if ( value == null )
                writer.write( NodeUtils.specialText(getFirstToken()) + strPrefix_ + "\\" +  nullString );
            else
                writer.write( NodeUtils.specialText(getFirstToken()) + strPrefix_ + nullString );
        
            return true;
        }

        /*
         *  the normal processing
         */

        if (value == null)
        {
            /* 
             *  write prefix twice, because it's shmoo, so the \ don't escape each other...
             */

            writer.write(NodeUtils.specialText(getFirstToken()) + strPrefix_ + strPrefix_ + nullString);
            
            if (referenceType != QUIET_REFERENCE && Runtime.getBoolean( RuntimeConstants.RUNTIME_LOG_REFERENCE_LOG_INVALID, true) )
                Runtime.warn(new ReferenceException("reference : template = " + context.getCurrentTemplateName(), this));
        }                    
        else
        {
            writer.write(NodeUtils.specialText(getFirstToken()) + strPrefix_ + value.toString());
        }                    
    
        return true;
    }

    /**
     *   Computes boolean value of this reference
     *   Returns the actual value of reference return type
     *   boolean, and 'true' if value is not null
     *
     *   @param context context to compute value with
     */
    public boolean evaluate(Context context)
    {
        Object value = execute(null, context);
        
        if (value == null)
            return false;
        else if (value instanceof Boolean)
        {
            if (((Boolean) value).booleanValue())
                return true;
            else
                return false;
        }
        else
            return true;
    }

    public Object value(Context context)
    {
        return execute(null, context);
    }

    public boolean setValue(Context context, Object value)
    {
        /*
         *  The rootOfIntrospection is the object we will
         *  retrieve from the Context. This is the base
         *  object we will apply reflection to.
         */

        Object result = getVariableValue(context, rootString);
        
        if (result == null)
        {
            Runtime.error(new ReferenceException("reference set : template = " + context.getCurrentTemplateName(), this));
            return false;
        }                          
        
        /*
         * How many child nodes do we have?
         */

         int children = jjtGetNumChildren();

        for (int i = 0; i < children - 1; i++)
        {
            result = jjtGetChild(i).execute(result, context);
            
            if (result == null)
            {
                Runtime.error(new ReferenceException("reference set : template = " + context.getCurrentTemplateName(), this));
                return false;
            }                          
        }            

        Object[] args = { value };
        Class[] params = { value.getClass() };
        
        /*
         * This catches the last phase of setting a property
         * if we catch an exception we know that something
         * like $provider.Monkey is not a valid reference.
         * $provider may be in the context, but Monkey is
         * not a method of $provider.
         */

        try
        {
            Class c = result.getClass();
            Method m = c.getMethod("set" + jjtGetChild(children - 1).getFirstToken().image, params);
            m.invoke(result, args);
        }
        catch (Exception e)
        {
            Runtime.error(new ReferenceException("reference set : template = " + context.getCurrentTemplateName(), this));
            return false;
        }
        
        return true;
    }

    private String getRoot()
    {
        Token t = getFirstToken();
         
        /*
         *  we need to see if this reference is escaped.  if so
         *  we will clean off the leading \'s and let the 
         *  regular behavior determine if we should output this
         *  as \$foo or $foo later on in render(). Lazyness..
         */

        bIsEscaped_ = false;

        if ( t.image.startsWith("\\"))
        {
            /* 
             *  count the escapes : even # -> not escaped, odd -> escaped
             */

            int i = 0;
            int iLen = t.image.length();

            while( i < iLen && t.image.charAt(i) == '\\' )
                i++;

            if ( (i % 2) != 0 )                
                bIsEscaped_ = true;

            if (i > 0)
                strPrefix_ = t.image.substring(0, i / 2 );

            t.image = t.image.substring(i);
        }
 
        /*
         *  geirm :   changed Parser.jjt to handle the $foo! bug 
         *  and the tree structure changed.  Leaving this stuff here
         *  for a little while in case something bad happens. :)
         *  following line was ->  if (t.image.equals("$!"))
         */

        if (t.image.startsWith("$!"))
        {
            referenceType = QUIET_REFERENCE;
            nullString = "";
            
            /*
             *  geirm : Parser.jjt change. was ->  if (t.next.image.equals("{"))
             */

            if (t.image.startsWith("$!{"))
            {
                /*
                 *  ex : $!{provider.Title} 
                 */

                /*
                 * geirm : Parser.jjt change.  Was -> return t.next.next.image;
                 */

                return t.next.image;
            }
            else
            {
                /*
                 *  ex : $!provider.Title
                 */
                
                /* 
                 *  geirm : Parser.jjt change.  Was -> return t.next.image;
                 */

                return t.image.substring(2);
            }
        }
        else if (t.image.equals("${"))
        {
            /*
             *  ex : ${provider.Title}
             */

            referenceType = FORMAL_REFERENCE;
            nullString = literal();
            return t.next.image;
        }            
        else
        {
            /*
             *  ex : $provider.Title
             */

            referenceType = NORMAL_REFERENCE;
            nullString = literal();
            return t.image.substring(1);
        }            
    }

    public Object getVariableValue(Context context, String variable)
    {
        if (context.containsKey(variable))
            return context.get(variable);
        else
            return null;
    }
}
